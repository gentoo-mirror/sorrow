diff --git a/Makefile.am b/Makefile.am
index 6060263..dc0768f 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -10,6 +10,10 @@ NULL =
 
 EXTRA_DIST = 			\
 	HACKING 		\
+	meson.build		\
+	meson_options.txt	\
+	meson_post_install.py	\
+	po/meson.build		\
 	$(NULL)
 
 # xsltproc barfs on 'make distcheck'; disable for now
diff --git a/actions/Makefile.am b/actions/Makefile.am
index 4498f4a..1709992 100644
--- a/actions/Makefile.am
+++ b/actions/Makefile.am
@@ -13,6 +13,9 @@ clean-local :
 
 DISTCLEANFILES = org.freedesktop.policykit.policy
 
-EXTRA_DIST = org.freedesktop.policykit.policy.in
+EXTRA_DIST =					\
+	org.freedesktop.policykit.policy.in	\
+	meson.build				\
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/actions/meson.build b/actions/meson.build
new file mode 100644
index 0000000..26d2d2d
--- /dev/null
+++ b/actions/meson.build
@@ -0,0 +1,10 @@
+policy = 'org.freedesktop.policykit.policy'
+
+custom_target(
+  policy,
+  input: policy + '.in',
+  output: '@BASENAME@',
+  command: intltool_xml_cmd,
+  install: true,
+  install_dir: pk_pkgactiondir,
+)
diff --git a/configure.ac b/configure.ac
index 4ac2219..d51cfbd 100644
--- a/configure.ac
+++ b/configure.ac
@@ -80,11 +80,22 @@ PKG_CHECK_MODULES(GLIB, [gmodule-2.0 gio-unix-2.0 >= 2.30.0])
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
-PKG_CHECK_MODULES(LIBJS, [mozjs-78])
-
-AC_SUBST(LIBJS_CFLAGS)
-AC_SUBST(LIBJS_CXXFLAGS)
-AC_SUBST(LIBJS_LIBS)
+dnl ---------------------------------------------------------------------------
+dnl - Check javascript backend
+dnl ---------------------------------------------------------------------------
+AC_ARG_WITH(duktape, AS_HELP_STRING([--with-duktape],[Use Duktape as javascript backend]),with_duktape=yes,with_duktape=no)
+AS_IF([test x${with_duktape} == xyes], [
+  PKG_CHECK_MODULES(LIBJS, [duktape >= 2.0.0 ])
+  AC_SUBST(LIBJS_CFLAGS)
+  AC_SUBST(LIBJS_LIBS)
+], [
+  PKG_CHECK_MODULES(LIBJS, [mozjs-78])
+
+  AC_SUBST(LIBJS_CFLAGS)
+  AC_SUBST(LIBJS_CXXFLAGS)
+  AC_SUBST(LIBJS_LIBS)
+])
+AM_CONDITIONAL(USE_DUKTAPE, [test x$with_duktape == xyes], [Using duktape as javascript engine library])
 
 EXPAT_LIB=""
 AC_ARG_WITH(expat, [  --with-expat=<dir>      Use expat from here],
@@ -581,6 +592,13 @@ echo "
         PAM support:                ${have_pam}
         systemdsystemunitdir:       ${systemdsystemunitdir}
         polkitd user:               ${POLKITD_USER}"
+if test "x${with_duktape}" = xyes; then
+echo "
+        Javascript engine:          Duktape"
+else
+echo "
+        Javascript engine:          Mozjs"
+fi
 
 if test "$have_pam" = yes ; then
 echo "
diff --git a/data/Makefile.am b/data/Makefile.am
index 7c53902..f5ee4ba 100644
--- a/data/Makefile.am
+++ b/data/Makefile.am
@@ -57,6 +57,7 @@ CLEANFILES = $(BUILT_SOURCES)
 EXTRA_DIST = 							\
 	org.freedesktop.PolicyKit1.Authority.xml 		\
 	org.freedesktop.PolicyKit1.AuthenticationAgent.xml 	\
+	meson.build						\
 	$(service_in_files) 					\
 	$(dbusconf_in_files) 					\
 	$(systemdservice_in_files) 				\
diff --git a/data/meson.build b/data/meson.build
new file mode 100644
index 0000000..14c100b
--- /dev/null
+++ b/data/meson.build
@@ -0,0 +1,47 @@
+service_conf = {'libprivdir': pk_prefix / pk_pkglibdir}
+
+configure_file(
+  input: 'org.freedesktop.PolicyKit1.service.in',
+  output: '@BASENAME@',
+  configuration: service_conf,
+  install: true,
+  install_dir: dbus_system_bus_services_dir,
+)
+
+configure_file(
+  input: 'org.freedesktop.PolicyKit1.conf.in',
+  output: '@BASENAME@',
+  configuration: {'polkitd_user': polkitd_user},
+  install: true,
+  install_dir: dbus_policydir,
+)
+
+if enable_pam
+  configure_file(
+    input: 'polkit-1.in',
+    output: '@BASENAME@',
+    configuration: pam_conf,
+    install: true,
+    install_dir: pk_sysconfdir / 'pam.d',
+  )
+endif
+
+its_data = files(
+  'polkit.its',
+  'polkit.loc',
+)
+
+install_data(
+  its_data,
+  install_dir: pk_datadir / 'gettext/its',
+)
+
+if enable_logind
+  configure_file(
+    input: 'polkit.service.in',
+    output: '@BASENAME@',
+    configuration: service_conf,
+    install: true,
+    install_dir: systemd_systemdsystemunitdir,
+  )
+endif
diff --git a/docs/Makefile.am b/docs/Makefile.am
index 8d7da9d..3c285e4 100644
--- a/docs/Makefile.am
+++ b/docs/Makefile.am
@@ -1,6 +1,9 @@
 
 SUBDIRS = man polkit
 
-EXTRA_DIST = version.xml.in
+EXTRA_DIST =		\
+	version.xml.in	\
+	meson.build	\
+	$(NULL)
 
 -include $(top_srcdir)/git.mk
diff --git a/docs/man/Makefile.am b/docs/man/Makefile.am
index 0b2dc44..38e037e 100644
--- a/docs/man/Makefile.am
+++ b/docs/man/Makefile.am
@@ -24,6 +24,7 @@ EXTRA_DIST = 				\
 	pkcheck.xml			\
 	pkaction.xml			\
 	pkttyagent.xml			\
+	meson.build			\
 	$(NULL)
 
 clean-local:
diff --git a/docs/man/meson.build b/docs/man/meson.build
new file mode 100644
index 0000000..241e82c
--- /dev/null
+++ b/docs/man/meson.build
@@ -0,0 +1,36 @@
+xsltproc = find_program('xsltproc', required: false)
+assert(xsltproc.found(), 'xsltproc is required for man pages generation')
+
+xsltproc_cmd = [
+  xsltproc,
+  '--output', '@OUTPUT@',
+  '--nonet',
+  '--stringparam', 'man.base.url.for.relative.links', pk_api_docpath + '/',
+  'http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl',
+  '@INPUT@',
+]
+
+mans = [
+  ['polkit', '8'],
+  ['polkitd', '8'],
+  ['pkexec', '1'],
+  ['pkcheck', '1'],
+  ['pkaction', '1'],
+  ['pkttyagent', '1'],
+]
+
+foreach man: mans
+  xml = files(man[0] + '.xml')
+  content_files += xml
+
+  output = '@0@.@1@'.format(man[0], man[1])
+
+  custom_target(
+    output,
+    input: xml,
+    output: output,
+    command: xsltproc_cmd,
+    install: true,
+    install_dir: pk_mandir / ('man' + man[1]),
+  )
+endforeach
diff --git a/docs/meson.build b/docs/meson.build
new file mode 100644
index 0000000..d4a0548
--- /dev/null
+++ b/docs/meson.build
@@ -0,0 +1,29 @@
+pk_api_docpath = pk_prefix / gnome.gtkdoc_html_dir(pk_api_name)
+
+enable_man = get_option('man')
+if enable_man
+  subdir('man')
+endif
+
+enable_gtk_doc = get_option('gtk_doc')
+if enable_gtk_doc
+  content_files += configure_file(
+    input: 'extensiondir.xml.in',
+    output: '@BASENAME@',
+    configuration: {'libdir': pk_prefix / pk_libdir},
+  )
+
+  content_files += configure_file(
+    input: 'version.xml.in',
+    output: '@BASENAME@',
+    configuration: {'VERSION': pk_version},
+  )
+
+  html_images = files(
+    'polkit-architecture.png',
+    'polkit-authentication-agent-example.png',
+    'polkit-authentication-agent-example-wheel.png',
+  )
+
+  subdir('polkit')
+endif
diff --git a/docs/polkit/Makefile.am b/docs/polkit/Makefile.am
index 1fce92c..2da0192 100644
--- a/docs/polkit/Makefile.am
+++ b/docs/polkit/Makefile.am
@@ -86,6 +86,8 @@ else
 CLEANFILES =
 endif
 
+EXTRA_DIST = meson.build
+
 CLEANFILES +=   *~				\
 		polkit-1-scan.*			\
 		polkit-1.args			\
diff --git a/docs/polkit/meson.build b/docs/polkit/meson.build
new file mode 100644
index 0000000..297a261
--- /dev/null
+++ b/docs/polkit/meson.build
@@ -0,0 +1,30 @@
+doc_module = pk_api_name
+
+src_dirs = [
+  source_root / 'src/polkit',
+  source_root / 'src/polkitagent',
+]
+
+private_headers = [
+  'polkitagenthelperprivate.h',
+  'polkitprivate.h',
+]
+
+content_files += files(
+  'docbook-interface-org.freedesktop.PolicyKit1.AuthenticationAgent.xml',
+  'docbook-interface-org.freedesktop.PolicyKit1.Authority.xml',
+)
+
+gnome.gtkdoc(
+  doc_module,
+  main_xml: doc_module + '-docs.xml',
+  src_dir: src_dirs,
+  ignore_headers: private_headers,
+  dependencies: libpolkit_agent_dep,
+  namespace: meson.project_name(),
+  html_assets: html_images,
+  fixxref_args: '--html-dir=' + pk_api_docpath,
+  gobject_typesfile: files(doc_module + '.types'),
+  content_files: content_files,
+  install: true,
+)
diff --git a/meson.build b/meson.build
new file mode 100644
index 0000000..75513c2
--- /dev/null
+++ b/meson.build
@@ -0,0 +1,373 @@
+project(
+  'polkit', ['c', 'cpp'],
+  version: '0.117',
+  license: 'LGPL2+',
+  default_options: [
+    'buildtype=debugoptimized',
+    'prefix=/usr',
+    'cpp_std=c++17',
+  ],
+  meson_version: '>= 0.50.0',
+)
+
+pk_version = meson.project_version()
+
+pk_api_version = '1'
+pk_api_name = '@0@-@1@'.format(meson.project_name(), pk_api_version)
+
+pk_gir_ns = 'Polkit'
+pk_gir_version = '1.0'
+
+pk_prefix = get_option('prefix')
+pk_datadir = get_option('datadir')
+pk_includedir = get_option('includedir')
+pk_libdir = get_option('libdir')
+pk_mandir = get_option('mandir')
+pk_sysconfdir = get_option('sysconfdir')
+
+pk_pkgdatadir = pk_datadir / pk_api_name
+pk_pkgincludedir = pk_includedir / pk_api_name
+pk_pkglibdir = pk_libdir / pk_api_name
+pk_pkgsysconfdir = pk_sysconfdir / pk_api_name
+
+pk_actiondir = pk_api_name / 'actions'
+pk_pkgactiondir = pk_datadir / pk_actiondir
+
+soversion = 0
+current = 0
+revision = 0
+libversion = '@0@.@1@.@2@'.format(soversion, current, revision)
+
+gnome = import('gnome')
+i18n = import('i18n')
+pkg = import('pkgconfig')
+
+source_root = meson.current_source_dir()
+build_root = meson.current_build_dir()
+
+data_dir = source_root / 'data'
+po_dir = source_root / 'po'
+
+intltool_merge = find_program('intltool-merge')
+intltool_cache = po_dir / '.intltool-merge-cache'
+intltool_desktop_cmd = [intltool_merge, '-d', '-u', '-c', intltool_cache, po_dir, '@INPUT@', '@OUTPUT@']
+intltool_xml_cmd = [intltool_merge, '-x', '-u', '-c', intltool_cache, po_dir, '@INPUT@', '@OUTPUT@']
+
+top_inc = include_directories('.')
+
+cc = meson.get_compiler('c')
+
+config_h = configuration_data()
+
+# defines
+set_defines = [
+  # package
+  ['PACKAGE_BUGREPORT', 'http://lists.freedesktop.org/mailman/listinfo/polkit-devel'],
+  ['PACKAGE_NAME', meson.project_name()],
+  ['PACKAGE_URL', 'http://www.freedesktop.org/wiki/Software/polkit'],
+  ['PACKAGE_VERSION', pk_version],
+  ['VERSION', pk_version],
+  # i18n
+  ['GETTEXT_PACKAGE', pk_api_name],
+]
+
+foreach define: set_defines
+  config_h.set_quoted(define[0], define[1])
+endforeach
+
+# Globally define_GNU_SOURCE and therefore enable the GNU extensions
+config_h.set('_GNU_SOURCE', true)
+
+# functions
+check_functions = [
+  'clearenv',
+  'fdatasync',
+]
+
+foreach func: check_functions
+  config_h.set('HAVE_' + func.to_upper(), cc.has_function(func))
+endforeach
+
+# compiler flags
+common_c_flags = [
+  # FIXME: this should go as 'c_std=c99' in project's default_options.
+  #        https://github.com/mesonbuild/meson/issues/1889
+  #        https://github.com/mesonbuild/meson/pull/6729
+  '-std=c99',
+  '-DHAVE_CONFIG_H',
+]
+compiler_flags = []
+compiler_c_flags = []
+
+if get_option('buildtype').contains('debug')
+  compiler_c_flags += cc.get_supported_arguments([
+    '-Waggregate-return',
+    '-Wdeclaration-after-statement',
+    '-Wformat=2',
+    '-Wimplicit-function-declaration',
+    '-Winit-self',
+    '-Wmissing-declarations',
+    '-Wmissing-include-dirs',
+    '-Wmissing-prototypes',
+    '-Wstrict-prototypes',
+  ])
+endif
+
+add_project_arguments(common_c_flags + compiler_c_flags, language: 'c')
+
+glib_req_version = '>= 2.30.0'
+
+gio_dep = dependency('gio-2.0', version: glib_req_version)
+gio_unix_dep = dependency('gio-unix-2.0', version: glib_req_version)
+glib_dep = dependency('glib-2.0', version: glib_req_version)
+gobject_dep = dependency('gobject-2.0', version: glib_req_version)
+
+expat_dep = dependency('expat')
+assert(cc.has_header('expat.h', dependencies: expat_dep), 'Can\'t find expat.h. Please install expat.')
+assert(cc.has_function('XML_ParserCreate', dependencies: expat_dep), 'Can\'t find expat library. Please install expat.')
+
+js_engine = get_option('js_engine')
+if js_engine == 'duktape'
+  js_dep = dependency('duktape')
+  libm_dep = cc.find_library('m')
+elif js_engine == 'mozjs'
+  js_dep = dependency('mozjs-78')
+endif
+
+dbus_dep = dependency('dbus-1')
+dbus_sysconfdir = dbus_dep.get_pkgconfig_variable('sysconfdir', define_variable: ['sysconfdir', pk_prefix / pk_sysconfdir])
+dbus_policydir = dbus_sysconfdir / 'dbus-1/system.d'
+dbus_system_bus_services_dir = dbus_dep.get_pkgconfig_variable('system_bus_services_dir', define_variable: ['datadir', pk_prefix / pk_datadir])
+
+# check OS
+host_system = host_machine.system()
+config_h.set('HAVE_' + host_system.to_upper(), true)
+
+# Check whether setnetgrent has a return value
+config_h.set('HAVE_NETGROUP_H', cc.has_header('netgroup.h'))
+
+setnetgrent_return_src = '''
+  #include <stddef.h>
+  #ifdef HAVE_NETGROUP_H
+  #include <netgroup.h>
+  #else
+  #include <netdb.h>
+  #endif
+  int main() {
+      int r = setnetgrent (NULL);
+  };
+'''
+
+config_h.set('HAVE_SETNETGRENT_RETURN', cc.compiles(setnetgrent_return_src, name: 'setnetgrent return support'))
+
+# Select wether to use libsystemd-login, libelogind or ConsoleKit for session tracking
+session_tracking = get_option('session_tracking')
+enable_logind = (session_tracking != 'ConsoleKit')
+if enable_logind
+  if session_tracking == 'libsystemd-login'
+    logind_dep = dependency('libsystemd', required: false)
+    if not logind_dep.found()
+      logind_dep = dependency('libsystemd-login', not_found_message: 'libsystemd support requested but libsystemd or libsystemd-login library not found')
+    endif
+  else
+    logind_dep = dependency('libelogind', not_found_message: 'libelogind support requested but libelogind library not found')
+  endif
+
+  func = 'sd_uid_get_display'
+  config_h.set10('HAVE_' + func.to_upper(), cc.has_function(func, dependencies: logind_dep))
+
+  # systemd unit / service files
+  systemd_systemdsystemunitdir = get_option('systemdsystemunitdir')
+  if systemd_systemdsystemunitdir == ''
+    systemd_dep = dependency('systemd', not_found_message: 'systemd required but not found, please provide a valid systemd user unit dir or disable it')
+    # FIXME: systemd.pc file does not use variables with relative paths, so `define_variable` cannot be used
+    systemd_systemdsystemunitdir = systemd_dep.get_pkgconfig_variable('systemdsystemunitdir')
+  endif
+endif
+config_h.set('HAVE_LIBSYSTEMD', enable_logind)
+
+# User for running polkitd
+polkitd_user = get_option('polkitd_user')
+config_h.set_quoted('POLKITD_USER', polkitd_user)
+
+# Select which authentication framework to use
+auth_deps = []
+
+auth_fw = get_option('authfw')
+enable_pam = (auth_fw == 'pam')
+if enable_pam
+  # Check for PAM
+  pam_dep = cc.find_library('pam')
+  assert(pam_dep.found() and cc.has_function('pam_start', dependencies: pam_dep), 'Could not find pam/pam-devel, please install the needed packages.')
+
+  # how to call pam_strerror
+  pam_strerror_src = '''
+    #include <stdio.h>
+    #include <stdlib.h>
+    #include <security/pam_appl.h>
+    #endif
+    int main() {
+      @0@
+    };
+  '''
+
+  # FIXME: Not necessary anymore?
+  if cc.compiles(pam_strerror_src.format('pam_handle_t *pamh = 0; char *s = pam_strerror(pamh, PAM_SUCCESS);'))
+    # FIXME: unused?
+    config_h.set('PAM_STRERROR_TWO_ARGS', true)
+  else
+    message('how to call pam_strerror: ' + cc.compiles(pam_strerror_src.format('char *s = pam_strerror(PAM_SUCCESS);')).to_string('1', 'unknown'))
+  endif
+
+  pam_prefix = get_option('pam_prefix')
+  if pam_prefix == ''
+    pam_prefix = pk_sysconfdir
+  else
+    message('PAM files will be installed in prefix ' + pam_prefix)
+  endif
+
+  pam_module_dir = get_option('pam_module_dir')
+  if pam_module_dir == ''
+    pam_module_dir = pk_libdir / 'security'
+  endif
+
+  auth_deps += pam_dep
+elif auth_fw == 'shadow'
+  auth_deps += cc.find_library('crypt')
+endif
+config_h.set('POLKIT_AUTHFW_' + auth_fw.to_upper(), true)
+
+# FIXME: sigtimedwait is not used anywhere?
+'''
+if host_system == 'solaris'
+  rt_dep = cc.find_library('rt')
+  cc.has_function('sigtimedwait', dependencies: rt_dep)
+else
+  cc.has_function('sigtimedwait')
+endif
+'''
+
+os_type = get_option('os_type')
+if os_type == ''
+  os_paths = [
+    ['redhat', '/etc/sysconfig/network-scripts'],
+    ['suse', '/etc/SuSE-release'],
+    ['debian', '/etc/debian_version'],
+    ['gentoo', '/etc/gentoo-release'],
+    ['pardus', '/etc/pardus-release'],
+  ]
+
+  foreach os_path: os_paths
+    if run_command('test', '-e', os_path[1]).returncode() == 0
+      os_type = os_path[0]
+      break
+    endif
+  endforeach
+
+  if os_type == ''
+    message('Linux distribution autodetection failed, specify the distribution to target using -Dos_type=')
+  endif
+endif
+
+pam_include = get_option('pam_include')
+if pam_include == ''
+  if ['suse', 'solaris'].contains(os_type)
+    pam_conf = {
+      'PAM_FILE_INCLUDE_AUTH': 'common-auth',
+      'PAM_FILE_INCLUDE_ACCOUNT': 'common-account',
+      'PAM_FILE_INCLUDE_PASSWORD': 'common-password',
+      'PAM_FILE_INCLUDE_SESSION': 'common-session',
+    }
+  elif os_type.contains('bsd')
+    pam_conf = {
+      'PAM_FILE_INCLUDE_AUTH': 'system',
+      'PAM_FILE_INCLUDE_ACCOUNT': 'system',
+      'PAM_FILE_INCLUDE_PASSWORD': 'system',
+      'PAM_FILE_INCLUDE_SESSION': 'system',
+    }
+  #if ['redhat', 'gentoo', 'pardus'].contains(os_type)
+  else
+    pam_conf = {
+      'PAM_FILE_INCLUDE_AUTH': 'system-auth',
+      'PAM_FILE_INCLUDE_ACCOUNT': 'system-auth',
+      'PAM_FILE_INCLUDE_PASSWORD': 'system-auth',
+      'PAM_FILE_INCLUDE_SESSION': 'system-auth',
+    }
+  endif
+else
+  pam_conf = {
+    'PAM_FILE_INCLUDE_AUTH': pam_include,
+    'PAM_FILE_INCLUDE_ACCOUNT': pam_include,
+    'PAM_FILE_INCLUDE_PASSWORD': pam_include,
+    'PAM_FILE_INCLUDE_SESSION': pam_include,
+  }
+endif
+
+enable_introspection = get_option('introspection')
+if enable_introspection
+  dependency('gobject-introspection-1.0', version: '>= 0.6.2')
+endif
+
+content_files = files('COPYING')
+
+subdir('actions')
+subdir('data')
+subdir('src')
+subdir('docs')
+subdir('po')
+
+enable_tests = get_option('tests')
+if enable_tests
+  subdir('test')
+endif
+
+configure_file(
+  output: 'config.h',
+  configuration: config_h,
+)
+
+meson.add_install_script(
+  'meson_post_install.py',
+  get_option('bindir'),
+  pk_pkgdatadir,
+  pk_pkglibdir,
+  pk_pkgsysconfdir,
+  polkitd_user,
+)
+
+output = '\n        ' + meson.project_name() + ' ' + meson.project_version() + '\n'
+output += '        ============\n\n'
+output += '        prefix:                   ' + pk_prefix + '\n'
+output += '        datadir:                  ' + pk_datadir + '\n\n'
+output += '        includedir:               ' + pk_includedir + '\n'
+output += '        libdir:                   ' + pk_libdir + '\n'
+output += '        sysconfdir:               ' + pk_sysconfdir + '\n'
+output += '        source code location:     ' + source_root + '\n'
+output += '        compiler:                 ' + cc.get_id() + '\n'
+output += '        c_flags:                  ' + ' '.join(compiler_c_flags) + '\n\n'
+if enable_man
+  output += '        xsltproc:                 ' + xsltproc.path() + '\n'
+endif
+output += '        introspection:            ' + enable_introspection.to_string() + '\n'
+output += '        Distribution/OS:          ' + os_type + '\n'
+output += '        Authentication framework: ' + auth_fw + '\n'
+output += '        Session tracking:         ' + session_tracking + '\n'
+if enable_logind
+  output += '        systemdsystemunitdir:     ' + systemd_systemdsystemunitdir + '\n'
+endif
+output += '        polkitd user:             ' + polkitd_user + ' \n'
+output += '        Javascript engine:        ' + js_engine + '\n'
+if enable_logind
+endif
+output += '        PAM support:              ' + enable_pam.to_string() + '\n\n'
+if enable_pam
+  output += '        PAM file auth:            ' + pam_conf['PAM_FILE_INCLUDE_AUTH'] + '\n'
+  output += '        PAM file acount:          ' + pam_conf['PAM_FILE_INCLUDE_ACCOUNT'] + '\n'
+  output += '        PAM file password:        ' + pam_conf['PAM_FILE_INCLUDE_PASSWORD'] + '\n'
+  output += '        PAM file session:         ' + pam_conf['PAM_FILE_INCLUDE_SESSION'] + '\n\n'
+endif
+output += '        Building api docs:        ' + enable_gtk_doc.to_string() + '\n'
+output += '        Building man pages:       ' + enable_man.to_string() + '\n'
+output += '        Building examples:        ' + enable_examples.to_string() + '\n'
+output += '        Building tests:           ' + enable_tests.to_string()
+message(output)
diff --git a/meson_options.txt b/meson_options.txt
new file mode 100644
index 0000000..76aa311
--- /dev/null
+++ b/meson_options.txt
@@ -0,0 +1,19 @@
+option('session_tracking', type: 'combo', choices: ['libsystemd-login', 'libelogind', 'ConsoleKit'], value: 'ConsoleKit', description: 'session tracking (libsystemd-login/libelogind/ConsoleKit)')
+option('systemdsystemunitdir', type: 'string', value: '', description: 'custom directory for systemd system units')
+
+option('polkitd_user', type: 'string', value: 'polkitd', description: 'User for running polkitd (polkitd)')
+
+option('authfw', type: 'combo', choices: ['pam', 'shadow', 'bsdauth'], value: 'pam', description: 'Authentication framework (pam/shadow)')
+option('os_type', type: 'combo', choices: ['redhat', 'suse', 'gentoo', 'pardus', 'solaris', 'netbsd', ''], value: '', description: 'distribution or OS')
+
+option('pam_include', type: 'string', value: '', description: 'pam file to include')
+option('pam_module_dir', type: 'string', value: '', description: 'directory to install PAM security module')
+option('pam_prefix', type: 'string', value: '', description: 'specify where pam files go')
+
+option('examples', type: 'boolean', value: false, description: 'Build example programs')
+option('tests', type: 'boolean', value: false, description: 'Build tests')
+option('introspection', type: 'boolean', value: true, description: 'Enable introspection for this build')
+
+option('gtk_doc', type: 'boolean', value: false, description: 'use gtk-doc to build documentation')
+option('man', type: 'boolean', value: false, description: 'build manual pages')
+option('js_engine', type: 'combo', choices: ['mozjs', 'duktape'], value: 'duktape', description: 'javascript engine')
diff --git a/meson_post_install.py b/meson_post_install.py
new file mode 100644
index 0000000..784d491
--- /dev/null
+++ b/meson_post_install.py
@@ -0,0 +1,37 @@
+#!/usr/bin/env python3
+
+import getpass
+import os
+import subprocess
+import sys
+
+prefix = os.environ['MESON_INSTALL_DESTDIR_PREFIX']
+
+bindir = os.path.join(prefix, sys.argv[1])
+pkgdatadir = os.path.join(prefix, sys.argv[2])
+pkglibdir = os.path.join(prefix, sys.argv[3])
+pkgsysconfdir = os.path.join(prefix, sys.argv[4])
+
+polkitd_user = sys.argv[5]
+
+subprocess.check_call(['chmod', '4755', os.path.join(bindir, 'pkexec')])
+
+dst_dirs = [
+    os.path.join(pkgsysconfdir, 'rules.d'),
+    os.path.join(pkgdatadir, 'rules.d')
+]
+
+for dst in dst_dirs:
+    if not os.path.exists(dst):
+        os.makedirs(dst)
+        subprocess.check_call(['chmod', '700', dst])
+        if getpass.getuser() == "root":
+            subprocess.check_call(['chown', polkitd_user, dst])
+
+# polkit-agent-helper-1 need to be setuid root because it's used to
+# authenticate not only the invoking user, but possibly also root
+# and/or other users.
+dst = os.path.join(pkglibdir, 'polkit-agent-helper-1')
+subprocess.check_call(['chmod', '4755', dst])
+if getpass.getuser() == "root":
+    subprocess.check_call(['chown', 'root', dst])
diff --git a/po/meson.build b/po/meson.build
new file mode 100644
index 0000000..4d9ab58
--- /dev/null
+++ b/po/meson.build
@@ -0,0 +1 @@
+i18n.gettext(pk_api_name, preset: 'glib')
diff --git a/src/Makefile.am b/src/Makefile.am
index 09fc7b3..b313826 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,6 +5,11 @@ if BUILD_EXAMPLES
 SUBDIRS += examples
 endif
 
+EXTRA_DIST =		\
+	meson.build	\
+	symbol.map	\
+	$(NULL)
+
 clean-local :
 	rm -f *~
 
diff --git a/src/examples/Makefile.am b/src/examples/Makefile.am
index 9b885f3..3ee373f 100644
--- a/src/examples/Makefile.am
+++ b/src/examples/Makefile.am
@@ -59,7 +59,10 @@ dist_polkit_action_DATA = org.freedesktop.policykit.examples.pkexec.policy
 
 DISTCLEANFILES = org.freedesktop.policykit.examples.pkexec.policy
 
-EXTRA_DIST = org.freedesktop.policykit.examples.pkexec.policy.in
+EXTRA_DIST =							\
+	org.freedesktop.policykit.examples.pkexec.policy.in	\
+	meson.build						\
+	$(NULL)
 
 # ----------------------------------------------------------------------------------------------------
 
diff --git a/src/examples/meson.build b/src/examples/meson.build
new file mode 100644
index 0000000..5f33afc
--- /dev/null
+++ b/src/examples/meson.build
@@ -0,0 +1,27 @@
+policy = 'org.freedesktop.policykit.examples.pkexec.policy'
+
+custom_target(
+  policy,
+  input: policy + '.in',
+  output: '@BASENAME@',
+  command: intltool_xml_cmd,
+  install: true,
+  install_dir: pk_pkgactiondir,
+)
+
+program = 'cancel'
+
+executable(
+  program,
+  program + '.c',
+  include_directories: top_inc,
+  dependencies: libpolkit_gobject_dep,
+)
+
+executable(
+  'pk-example-frobnicate',
+  'frobnicate.c',
+  include_directories: top_inc,
+  dependencies: glib_dep,
+  install: true,
+)
diff --git a/src/meson.build b/src/meson.build
new file mode 100644
index 0000000..4073333
--- /dev/null
+++ b/src/meson.build
@@ -0,0 +1,14 @@
+src_inc = include_directories('.')
+
+symbol_map = meson.current_source_dir() / 'symbol.map'
+ldflags = cc.get_supported_link_arguments('-Wl,--version-script,@0@'.format(symbol_map))
+
+subdir('polkit')
+subdir('polkitbackend')
+subdir('polkitagent')
+subdir('programs')
+
+enable_examples = get_option('examples')
+if enable_examples
+  subdir('examples')
+endif
diff --git a/src/polkit/Makefile.am b/src/polkit/Makefile.am
index ca36355..2fb5616 100644
--- a/src/polkit/Makefile.am
+++ b/src/polkit/Makefile.am
@@ -129,7 +129,12 @@ include $(INTROSPECTION_MAKEFILE)
 
 endif # HAVE_INTROSPECTION
 
-EXTRA_DIST = polkitenumtypes.h.template polkitenumtypes.c.template
+EXTRA_DIST =				\
+	polkitenumtypes.h.template	\
+	polkitenumtypes.c.template	\
+	meson.build			\
+	$(NULL)
+
 CLEANFILES = $(gir_DATA) $(typelibs_DATA)
 
 dist-hook :
diff --git a/src/polkit/meson.build b/src/polkit/meson.build
new file mode 100644
index 0000000..63dc1e8
--- /dev/null
+++ b/src/polkit/meson.build
@@ -0,0 +1,135 @@
+name = '@0@-gobject-@1@'.format(meson.project_name(), pk_api_version)
+
+enum_headers = files(
+  'polkitauthorityfeatures.h',
+  'polkitcheckauthorizationflags.h',
+  'polkiterror.h',
+  'polkitimplicitauthorization.h',
+)
+
+headers = enum_headers + files(
+  'polkitactiondescription.h',
+  'polkitauthority.h',
+  'polkitauthorizationresult.h',
+  'polkitdetails.h',
+  'polkit.h',
+  'polkitidentity.h',
+  'polkitpermission.h',
+  'polkitsubject.h',
+  'polkitsystembusname.h',
+  'polkittemporaryauthorization.h',
+  'polkitunixgroup.h',
+  'polkitunixnetgroup.h',
+  'polkitunixprocess.h',
+  'polkitunixsession.h',
+  'polkitunixuser.h',
+)
+
+private_headers = files(
+  'polkitprivate.h',
+  'polkittypes.h',
+)
+
+install_headers(
+  headers + private_headers,
+  install_dir: pk_pkgincludedir / 'polkit',
+)
+
+common_deps = [
+  gio_dep,
+  glib_dep,
+]
+
+enum_sources = gnome.mkenums_simple(
+  'polkitenumtypes',
+  sources: enum_headers,
+  install_header: true,
+  install_dir: pk_pkgincludedir / 'polkit',
+)
+
+sources = enum_sources + files(
+  'polkitactiondescription.c',
+  'polkitauthority.c',
+  'polkitauthorityfeatures.c',
+  'polkitauthorizationresult.c',
+  'polkitcheckauthorizationflags.c',
+  'polkitdetails.c',
+  'polkiterror.c',
+  'polkitidentity.c',
+  'polkitimplicitauthorization.c',
+  'polkitpermission.c',
+  'polkitsubject.c',
+  'polkitsystembusname.c',
+  'polkittemporaryauthorization.c',
+  'polkitunixgroup.c',
+  'polkitunixnetgroup.c',
+  'polkitunixprocess.c',
+  'polkitunixuser.c',
+)
+
+incs = [
+  top_inc,
+  src_inc,
+]
+
+deps = common_deps
+
+c_flags = '-D_POLKIT_COMPILATION'
+
+if enable_logind
+  sources += 'polkitunixsession-systemd.c'
+
+  deps += logind_dep
+else
+  sources += 'polkitunixsession.c'
+endif
+
+libpolkit_gobject = shared_library(
+  name,
+  sources: sources,
+  version: libversion,
+  include_directories: incs,
+  dependencies: deps,
+  c_args: c_flags,
+  link_args: ldflags,
+  link_depends: symbol_map,
+  install: true,
+)
+
+libpolkit_gobject_dep = declare_dependency(
+  sources: enum_sources[1],
+  include_directories: src_inc,
+  dependencies: common_deps,
+  link_with: libpolkit_gobject,
+)
+
+pkg.generate(
+  libraries: libpolkit_gobject,
+  version: pk_version,
+  name: name,
+  description: 'PolicyKit Authorization API',
+  filebase: name,
+  subdirs: pk_api_name,
+  requires: common_deps,
+  variables: [
+    'exec_prefix=${prefix}',
+    'datadir=' + ('${prefix}' / pk_datadir),
+    'policydir=' + ('${datadir}' / pk_actiondir),
+    'actiondir=' + ('${datadir}' / pk_actiondir),
+    'pkcheck_supports_uid=true',
+  ],
+)
+
+if enable_introspection
+  libpolkit_gobject_gir = gnome.generate_gir(
+    libpolkit_gobject,
+    sources: sources + headers,
+    extra_args: c_flags,
+    nsversion: pk_gir_version,
+    namespace: pk_gir_ns,
+    export_packages: name,
+    includes: 'Gio-2.0',
+    header: 'polkit/polkit.h',
+    install: true,
+  )
+endif
diff --git a/src/polkitagent/Makefile.am b/src/polkitagent/Makefile.am
index 49720db..c98f29d 100644
--- a/src/polkitagent/Makefile.am
+++ b/src/polkitagent/Makefile.am
@@ -150,7 +150,13 @@ install-data-hook:
 	-chown root $(DESTDIR)$(libprivdir)/polkit-agent-helper-1
 	-chmod 4755 $(DESTDIR)$(libprivdir)/polkit-agent-helper-1
 
-EXTRA_DIST = polkitagentmarshal.list polkitagentenumtypes.h.template polkitagentenumtypes.c.template
+EXTRA_DIST =				\
+	polkitagentmarshal.list		\
+	polkitagentenumtypes.h.template	\
+	polkitagentenumtypes.c.template	\
+	meson.build			\
+	$(NULL)
+
 CLEANFILES = $(gir_DATA) $(typelibs_DATA)
 
 dist-hook :
diff --git a/src/polkitagent/meson.build b/src/polkitagent/meson.build
new file mode 100644
index 0000000..84aa260
--- /dev/null
+++ b/src/polkitagent/meson.build
@@ -0,0 +1,119 @@
+name = '@0@-agent-@1@'.format(meson.project_name(), pk_api_version)
+
+enum_headers = files('polkitagentlistener.h')
+
+headers = enum_headers + files(
+  'polkitagent.h',
+  'polkitagentsession.h',
+  'polkitagenttextlistener.h',
+  'polkitagenttypes.h',
+)
+
+install_headers(
+  headers,
+  install_dir: pk_pkgincludedir / 'polkitagent',
+)
+
+enum_sources = gnome.mkenums_simple(
+  'polkitagentenumtypes',
+  sources: enum_headers,
+  install_header: true,
+  install_dir: pk_pkgincludedir / 'polkitagent',
+)
+
+marshal = 'polkitagentmarshal'
+
+marshal_sources = gnome.genmarshal(
+  marshal,
+  sources: marshal + '.list',
+  prefix: '_polkit_agent_marshal',
+)
+
+sources = enum_sources + marshal_sources + files(
+  'polkitagentlistener.c',
+  'polkitagentsession.c',
+  'polkitagenttextlistener.c',
+)
+
+deps = [
+  expat_dep,
+  gio_unix_dep,
+  libpolkit_gobject_dep,
+]
+
+c_flags = [
+  '-D_POLKIT_COMPILATION',
+  '-D_POLKIT_AGENT_COMPILATION',
+  '-DPACKAGE_PREFIX="@0@"'.format(pk_prefix),
+]
+
+libpolkit_agent = shared_library(
+  name,
+  sources: sources,
+  version: libversion,
+  include_directories: top_inc,
+  dependencies: deps,
+  c_args: c_flags,
+  link_args: ldflags,
+  link_depends: symbol_map,
+  install: true,
+)
+
+libpolkit_agent_dep = declare_dependency(
+  sources: enum_sources[1],
+  include_directories: '.',
+  dependencies: libpolkit_gobject_dep,
+  link_with: libpolkit_agent,
+)
+
+pkg.generate(
+  libraries: libpolkit_agent,
+  version: pk_version,
+  name: name,
+  description: 'PolicyKit Authentication Agent API',
+  filebase: name,
+  subdirs: pk_api_name,
+  requires: 'polkit-gobject-1',
+  variables: 'exec_prefix=${prefix}',
+)
+
+if enable_introspection
+  incs = [
+    'Gio-2.0',
+    libpolkit_gobject_gir[0],
+  ]
+
+  c_flags = [
+    '-D_POLKIT_AGENT_COMPILATION',
+    '-D_POLKIT_COMPILATION',
+  ]
+
+  gnome.generate_gir(
+    libpolkit_agent,
+    sources: sources + headers,
+    includes: incs,
+    extra_args: c_flags,
+    nsversion: pk_gir_version,
+    namespace: 'PolkitAgent',
+    export_packages: name,
+    header: 'polkitagent/polkitagent.h',
+    install: true,
+  )
+endif
+
+sources = files(
+  'polkitagenthelperprivate.c',
+  'polkitagenthelper-@0@.c'.format(auth_fw),
+)
+
+deps = auth_deps + [libpolkit_gobject_dep]
+
+executable(
+  '@0@-agent-helper-@1@'.format(meson.project_name(), pk_api_version),
+  sources,
+  include_directories: top_inc,
+  dependencies: deps,
+  c_args: '-D_POLKIT_COMPILATION',
+  install: true,
+  install_dir: pk_pkglibdir,
+)
diff --git a/src/polkitagent/polkitagenttextlistener.c b/src/polkitagent/polkitagenttextlistener.c
index d864dfb..0ba0352 100644
--- a/src/polkitagent/polkitagenttextlistener.c
+++ b/src/polkitagent/polkitagenttextlistener.c
@@ -62,6 +62,17 @@ struct _PolkitAgentTextListener
   GCancellable *cancellable;
 
   FILE *tty;
+
+  gboolean use_color;
+  gboolean use_alternate_buffer;
+  guint delay;
+};
+
+enum {
+  PROP_ZERO,
+  PROP_USE_COLOR,
+  PROP_USE_ALTERNATE_BUFFER,
+  PROP_DELAY
 };
 
 typedef struct
@@ -92,6 +103,9 @@ G_DEFINE_TYPE_WITH_CODE (PolkitAgentTextListener, polkit_agent_text_listener, PO
 static void
 polkit_agent_text_listener_init (PolkitAgentTextListener *listener)
 {
+  listener->use_color = TRUE;
+  listener->use_alternate_buffer = FALSE;
+  listener->delay = 1;
 }
 
 static void
@@ -109,6 +123,56 @@ polkit_agent_text_listener_finalize (GObject *object)
     G_OBJECT_CLASS (polkit_agent_text_listener_parent_class)->finalize (object);
 }
 
+static void
+polkit_agent_text_listener_set_property (GObject      *object,
+                                         guint         prop_id,
+                                         const GValue *value,
+                                         GParamSpec   *pspec)
+{
+  PolkitAgentTextListener *listener = POLKIT_AGENT_TEXT_LISTENER (object);
+
+  switch (prop_id)
+    {
+    case PROP_USE_COLOR:
+      listener->use_color = g_value_get_boolean (value);
+      break;
+    case PROP_USE_ALTERNATE_BUFFER:
+      listener->use_alternate_buffer = g_value_get_boolean (value);
+      break;
+    case PROP_DELAY:
+      listener->delay = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+polkit_agent_text_listener_get_property (GObject    *object,
+                                         guint       prop_id,
+                                         GValue     *value,
+                                         GParamSpec *pspec)
+{
+  PolkitAgentTextListener *listener = POLKIT_AGENT_TEXT_LISTENER (object);
+
+  switch (prop_id)
+    {
+    case PROP_USE_COLOR:
+      g_value_set_boolean (value, listener->use_color);
+      break;
+    case PROP_USE_ALTERNATE_BUFFER:
+      g_value_set_boolean (value, listener->use_alternate_buffer);
+      break;
+    case PROP_DELAY:
+      g_value_set_uint (value, listener->delay);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
 static void
 polkit_agent_text_listener_class_init (PolkitAgentTextListenerClass *klass)
 {
@@ -117,10 +181,30 @@ polkit_agent_text_listener_class_init (PolkitAgentTextListenerClass *klass)
 
   gobject_class = G_OBJECT_CLASS (klass);
   gobject_class->finalize = polkit_agent_text_listener_finalize;
+  gobject_class->get_property = polkit_agent_text_listener_get_property;
+  gobject_class->set_property = polkit_agent_text_listener_set_property;
 
   listener_class = POLKIT_AGENT_LISTENER_CLASS (klass);
   listener_class->initiate_authentication        = polkit_agent_text_listener_initiate_authentication;
   listener_class->initiate_authentication_finish = polkit_agent_text_listener_initiate_authentication_finish;
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_USE_COLOR,
+                                   g_param_spec_boolean ("use-color", "", "",
+                                                         TRUE,
+                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_USE_ALTERNATE_BUFFER,
+                                   g_param_spec_boolean ("use-alternate-buffer", "", "",
+                                                         FALSE,
+                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_DELAY,
+                                   g_param_spec_uint ("delay", "", "",
+                                                      0, G_MAXUINT, 1,
+                                                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
 }
 
 /**
@@ -204,12 +288,19 @@ on_completed (PolkitAgentSession *session,
 {
   PolkitAgentTextListener *listener = POLKIT_AGENT_TEXT_LISTENER (user_data);
 
-  fprintf (listener->tty, "\x1B[1;31m");
+  if (listener->use_color)
+    fprintf (listener->tty, "\x1B[1;31m");
   if (gained_authorization)
     fprintf (listener->tty, "==== AUTHENTICATION COMPLETE ====\n");
   else
     fprintf (listener->tty, "==== AUTHENTICATION FAILED ====\n");
-  fprintf (listener->tty, "\x1B[0m");
+  if (listener->use_color)
+    fprintf (listener->tty, "\x1B[0m");
+  if (listener->use_alternate_buffer)
+    {
+      sleep (listener->delay);
+      fprintf (listener->tty, "\x1B[?1049l");
+    }
   fflush (listener->tty);
 
   g_simple_async_result_complete_in_idle (listener->simple);
@@ -471,11 +562,15 @@ polkit_agent_text_listener_initiate_authentication (PolkitAgentListener  *_liste
 
   g_assert (g_list_length (identities) >= 1);
 
-  fprintf (listener->tty, "\x1B[1;31m");
+  if (listener->use_alternate_buffer)
+    fprintf (listener->tty, "\x1B[?1049h");
+  if (listener->use_color)
+    fprintf (listener->tty, "\x1B[1;31m");
   fprintf (listener->tty,
            "==== AUTHENTICATING FOR %s ====\n",
            action_id);
-  fprintf (listener->tty, "\x1B[0m");
+  if (listener->use_color)
+    fprintf (listener->tty, "\x1B[0m");
   fprintf (listener->tty,
            "%s\n",
            message);
@@ -486,9 +581,11 @@ polkit_agent_text_listener_initiate_authentication (PolkitAgentListener  *_liste
       identity = choose_identity (listener, identities);
       if (identity == NULL)
         {
-          fprintf (listener->tty, "\x1B[1;31m");
+          if (listener->use_color)
+            fprintf (listener->tty, "\x1B[1;31m");
           fprintf (listener->tty, "==== AUTHENTICATION CANCELED ====\n");
-          fprintf (listener->tty, "\x1B[0m");
+          if (listener->use_color)
+            fprintf (listener->tty, "\x1B[0m");
           fflush (listener->tty);
           g_simple_async_result_set_error (simple,
                                            POLKIT_ERROR,
diff --git a/src/polkitbackend/Makefile.am b/src/polkitbackend/Makefile.am
index e48b739..abcbc6f 100644
--- a/src/polkitbackend/Makefile.am
+++ b/src/polkitbackend/Makefile.am
@@ -33,7 +33,7 @@ libpolkit_backend_1_la_SOURCES =                                   			\
 	polkitbackendprivate.h								\
 	polkitbackendauthority.h		polkitbackendauthority.c		\
 	polkitbackendinteractiveauthority.h	polkitbackendinteractiveauthority.c	\
-	polkitbackendjsauthority.h		polkitbackendjsauthority.cpp		\
+	polkitbackendjsauthority.h				\
 	polkitbackendactionpool.h		polkitbackendactionpool.c		\
 	polkitbackendactionlookup.h		polkitbackendactionlookup.c		\
         $(NULL)
@@ -51,19 +51,27 @@ libpolkit_backend_1_la_CFLAGS =                                        	\
         -D_POLKIT_BACKEND_COMPILATION                                  	\
         $(GLIB_CFLAGS)							\
 	$(LIBSYSTEMD_CFLAGS)						\
-	$(LIBJS_CFLAGS)							\
+	$(LIBJS_CFLAGS)						\
         $(NULL)
 
 libpolkit_backend_1_la_CXXFLAGS = $(libpolkit_backend_1_la_CFLAGS)
 
 libpolkit_backend_1_la_LIBADD =                               		\
         $(GLIB_LIBS)							\
+        $(DUKTAPE_LIBS)							\
 	$(LIBSYSTEMD_LIBS)						\
 	$(top_builddir)/src/polkit/libpolkit-gobject-1.la		\
 	$(EXPAT_LIBS)							\
-	$(LIBJS_LIBS)							\
+	$(LIBJS_LIBS)                                                   \
         $(NULL)
 
+if USE_DUKTAPE
+libpolkit_backend_1_la_SOURCES += polkitbackendduktapeauthority.c
+libpolkit_backend_1_la_LIBADD += -lm
+else
+libpolkit_backend_1_la_SOURCES += polkitbackendjsauthority.cpp
+endif
+
 rulesdir = $(sysconfdir)/polkit-1/rules.d
 rules_DATA = 50-default.rules
 
@@ -99,6 +107,7 @@ CLEANFILES = $(BUILT_SOURCES)
 EXTRA_DIST =								\
 	init.js								\
 	toarray.pl							\
+	meson.build							\
 	$(rules_DATA)							\
 	$(NULL)
 
diff --git a/src/polkitbackend/meson.build b/src/polkitbackend/meson.build
new file mode 100644
index 0000000..d7d3b02
--- /dev/null
+++ b/src/polkitbackend/meson.build
@@ -0,0 +1,78 @@
+name = '@0@-backend-@1@'.format(meson.project_name(), pk_api_version)
+
+sources = files(
+  'polkitbackendactionlookup.c',
+  'polkitbackendactionpool.c',
+  'polkitbackendauthority.c',
+  'polkitbackendinteractiveauthority.c',
+)
+
+output = 'initjs.h'
+
+sources += custom_target(
+  output,
+  input: 'init.js',
+  output: output,
+  capture: true,
+  command: [find_program('perl'), meson.current_source_dir() / 'toarray.pl', '@INPUT@', 'init_js'],
+)
+
+deps = [
+  expat_dep,
+  libpolkit_gobject_dep,
+  js_dep,
+]
+
+c_flags = [
+  '-D_POLKIT_COMPILATION',
+  '-D_POLKIT_BACKEND_COMPILATION',
+  '-DPACKAGE_DATA_DIR="@0@"'.format(pk_prefix / pk_datadir),
+  '-DPACKAGE_SYSCONF_DIR="@0@"'.format(pk_prefix / pk_sysconfdir),
+]
+
+if js_engine == 'duktape'
+  sources += files('polkitbackendduktapeauthority.c')
+  deps += libm_dep
+elif js_engine == 'mozjs'
+  sources += files('polkitbackendjsauthority.cpp')
+endif
+
+if enable_logind
+  sources += files('polkitbackendsessionmonitor-systemd.c')
+
+  deps += logind_dep
+else
+  sources += files('polkitbackendsessionmonitor.c')
+endif
+
+libpolkit_backend = static_library(
+  name,
+  sources: sources,
+  include_directories: top_inc,
+  dependencies: deps,
+  c_args: c_flags,
+  cpp_args: c_flags,
+)
+
+install_data(
+  '50-default.rules',
+  install_dir: pk_pkgsysconfdir / 'rules.d',
+)
+
+program = 'polkitd'
+
+c_flags = [
+  '-DG_LOG_DOMAIN="@0@-@1@"'.format(program, pk_api_version),
+  '-DPOLKIT_BACKEND_I_KNOW_API_IS_SUBJECT_TO_CHANGE',
+]
+
+executable(
+  program,
+  program + '.c',
+  include_directories: top_inc,
+  dependencies: libpolkit_gobject_dep,
+  c_args: c_flags,
+  link_with: libpolkit_backend,
+  install: true,
+  install_dir: pk_pkglibdir,
+)
diff --git a/src/polkitbackend/polkitbackendduktapeauthority.c b/src/polkitbackend/polkitbackendduktapeauthority.c
new file mode 100644
index 0000000..4b4f8fd
--- /dev/null
+++ b/src/polkitbackend/polkitbackendduktapeauthority.c
@@ -0,0 +1,1428 @@
+/*
+ * Copyright (C) 2008-2012 Red Hat, Inc.
+ * Copyright (C) 2015 Tangent Space <jstpierre@mecheye.net>
+ * Copyright (C) 2019 Wu Xiaotian <yetist@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Author: David Zeuthen <davidz@redhat.com>
+ */
+
+#include "config.h"
+#include <sys/wait.h>
+#include <errno.h>
+#include <pwd.h>
+#include <grp.h>
+#ifdef HAVE_NETGROUP_H
+#include <netgroup.h>
+#else
+#include <netdb.h>
+#endif
+#include <string.h>
+#include <glib/gstdio.h>
+#include <locale.h>
+#include <glib/gi18n-lib.h>
+
+#include <polkit/polkit.h>
+#include "polkitbackendjsauthority.h"
+
+#include <polkit/polkitprivate.h>
+
+#ifdef HAVE_LIBSYSTEMD
+#include <systemd/sd-login.h>
+#endif /* HAVE_LIBSYSTEMD */
+
+#include "initjs.h" /* init.js */
+#include "duktape.h"
+
+/**
+ * SECTION:polkitbackendjsauthority
+ * @title: PolkitBackendJsAuthority
+ * @short_description: JS Authority
+ * @stability: Unstable
+ *
+ * An implementation of #PolkitBackendAuthority that reads and
+ * evalates Javascript files and supports interaction with
+ * authentication agents (virtue of being based on
+ * #PolkitBackendInteractiveAuthority).
+ */
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+struct _PolkitBackendJsAuthorityPrivate
+{
+  gchar **rules_dirs;
+  GFileMonitor **dir_monitors; /* NULL-terminated array of GFileMonitor instances */
+  duk_context *cx;
+};
+
+
+static void utils_spawn (const gchar *const  *argv,
+                         guint                timeout_seconds,
+                         GCancellable        *cancellable,
+                         GAsyncReadyCallback  callback,
+                         gpointer             user_data);
+
+gboolean utils_spawn_finish (GAsyncResult   *res,
+                             gint           *out_exit_status,
+                             gchar         **out_standard_output,
+                             gchar         **out_standard_error,
+                             GError        **error);
+
+static void on_dir_monitor_changed (GFileMonitor     *monitor,
+                                    GFile            *file,
+                                    GFile            *other_file,
+                                    GFileMonitorEvent event_type,
+                                    gpointer          user_data);
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+enum
+{
+  PROP_0,
+  PROP_RULES_DIRS,
+};
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static GList *polkit_backend_js_authority_get_admin_auth_identities (PolkitBackendInteractiveAuthority *authority,
+                                                                     PolkitSubject                     *caller,
+                                                                     PolkitSubject                     *subject,
+                                                                     PolkitIdentity                    *user_for_subject,
+                                                                     gboolean                           subject_is_local,
+                                                                     gboolean                           subject_is_active,
+                                                                     const gchar                       *action_id,
+                                                                     PolkitDetails                     *details);
+
+static PolkitImplicitAuthorization polkit_backend_js_authority_check_authorization_sync (
+                                                          PolkitBackendInteractiveAuthority *authority,
+                                                          PolkitSubject                     *caller,
+                                                          PolkitSubject                     *subject,
+                                                          PolkitIdentity                    *user_for_subject,
+                                                          gboolean                           subject_is_local,
+                                                          gboolean                           subject_is_active,
+                                                          const gchar                       *action_id,
+                                                          PolkitDetails                     *details,
+                                                          PolkitImplicitAuthorization        implicit);
+
+G_DEFINE_TYPE (PolkitBackendJsAuthority, polkit_backend_js_authority, POLKIT_BACKEND_TYPE_INTERACTIVE_AUTHORITY);
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static duk_ret_t js_polkit_log (duk_context *cx);
+static duk_ret_t js_polkit_spawn (duk_context *cx);
+static duk_ret_t js_polkit_user_is_in_netgroup (duk_context *cx);
+
+static const duk_function_list_entry js_polkit_functions[] =
+{
+  { "log", js_polkit_log, 1 },
+  { "spawn", js_polkit_spawn, 1 },
+  { "_userIsInNetGroup", js_polkit_user_is_in_netgroup, 2 },
+  { NULL, NULL, 0 },
+};
+
+static void
+polkit_backend_js_authority_init (PolkitBackendJsAuthority *authority)
+{
+  authority->priv = G_TYPE_INSTANCE_GET_PRIVATE (authority,
+                                                 POLKIT_BACKEND_TYPE_JS_AUTHORITY,
+                                                 PolkitBackendJsAuthorityPrivate);
+}
+
+static gint
+rules_file_name_cmp (const gchar *a,
+                     const gchar *b)
+{
+  gint ret;
+  const gchar *a_base;
+  const gchar *b_base;
+
+  a_base = strrchr (a, '/');
+  b_base = strrchr (b, '/');
+
+  g_assert (a_base != NULL);
+  g_assert (b_base != NULL);
+  a_base += 1;
+  b_base += 1;
+
+  ret = g_strcmp0 (a_base, b_base);
+  if (ret == 0)
+    {
+      /* /etc wins over /usr */
+      ret = g_strcmp0 (a, b);
+      g_assert (ret != 0);
+    }
+
+  return ret;
+}
+
+static void
+load_scripts (PolkitBackendJsAuthority  *authority)
+{
+  duk_context *cx = authority->priv->cx;
+  GList *files = NULL;
+  GList *l;
+  guint num_scripts = 0;
+  GError *error = NULL;
+  guint n;
+
+  files = NULL;
+
+  for (n = 0; authority->priv->rules_dirs != NULL && authority->priv->rules_dirs[n] != NULL; n++)
+    {
+      const gchar *dir_name = authority->priv->rules_dirs[n];
+      GDir *dir = NULL;
+
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Loading rules from directory %s",
+                                    dir_name);
+
+      dir = g_dir_open (dir_name,
+                        0,
+                        &error);
+      if (dir == NULL)
+        {
+          polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                        "Error opening rules directory: %s (%s, %d)",
+                                        error->message, g_quark_to_string (error->domain), error->code);
+          g_clear_error (&error);
+        }
+      else
+        {
+          const gchar *name;
+          while ((name = g_dir_read_name (dir)) != NULL)
+            {
+              if (g_str_has_suffix (name, ".rules"))
+                files = g_list_prepend (files, g_strdup_printf ("%s/%s", dir_name, name));
+            }
+          g_dir_close (dir);
+        }
+    }
+
+  files = g_list_sort (files, (GCompareFunc) rules_file_name_cmp);
+
+  for (l = files; l != NULL; l = l->next)
+    {
+      const gchar *filename = (gchar *)l->data;
+#if (DUK_VERSION >= 20000)
+      GFile *file = g_file_new_for_path (filename);
+      char *contents;
+      gsize len;
+      if (!g_file_load_contents (file, NULL, &contents, &len, NULL, NULL))
+        {
+          polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                        "Error compiling script %s",
+                                        filename);
+          g_object_unref (file);
+          continue;
+        }
+
+      g_object_unref (file);
+      if (duk_peval_lstring_noresult(cx, contents,len) != 0)
+#else
+      if (duk_peval_file_noresult (cx, filename) != 0)
+#endif
+        {
+          polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                        "Error compiling script %s: %s",
+                                        filename, duk_safe_to_string (authority->priv->cx, -1));
+#if (DUK_VERSION >= 20000)
+          g_free (contents);
+#endif
+          continue;
+        }
+#if (DUK_VERSION >= 20000)
+      g_free (contents);
+#endif
+      num_scripts++;
+    }
+
+  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                "Finished loading, compiling and executing %d rules",
+                                num_scripts);
+  g_list_free_full (files, g_free);
+}
+
+static void
+reload_scripts (PolkitBackendJsAuthority *authority)
+{
+  duk_context *cx = authority->priv->cx;
+
+  duk_set_top (cx, 0);
+  if (!duk_get_global_string (cx, "polkit")) {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error deleting old rules, not loading new ones");
+      return;
+  }
+  duk_push_string (cx, "_deleteRules");
+
+  duk_call_prop (cx, 0, 0);
+
+  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                "Collecting garbage unconditionally...");
+
+  load_scripts (authority);
+
+  /* Let applications know we have new rules... */
+  g_signal_emit_by_name (authority, "changed");
+}
+
+static void
+on_dir_monitor_changed (GFileMonitor     *monitor,
+                        GFile            *file,
+                        GFile            *other_file,
+                        GFileMonitorEvent event_type,
+                        gpointer          user_data)
+{
+  PolkitBackendJsAuthority *authority = POLKIT_BACKEND_JS_AUTHORITY (user_data);
+
+  /* TODO: maybe rate-limit so storms of events are collapsed into one with a 500ms resolution?
+   *       Because when editing a file with emacs we get 4-8 events..
+   */
+
+  if (file != NULL)
+    {
+      gchar *name;
+
+      name = g_file_get_basename (file);
+
+      /* g_print ("event_type=%d file=%p name=%s\n", event_type, file, name); */
+      if (!g_str_has_prefix (name, ".") &&
+          !g_str_has_prefix (name, "#") &&
+          g_str_has_suffix (name, ".rules") &&
+          (event_type == G_FILE_MONITOR_EVENT_CREATED ||
+           event_type == G_FILE_MONITOR_EVENT_DELETED ||
+           event_type == G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT))
+        {
+          polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                        "Reloading rules");
+          reload_scripts (authority);
+        }
+      g_free (name);
+    }
+}
+
+
+static void
+setup_file_monitors (PolkitBackendJsAuthority *authority)
+{
+  guint n;
+  GPtrArray *p;
+
+  p = g_ptr_array_new ();
+  for (n = 0; authority->priv->rules_dirs != NULL && authority->priv->rules_dirs[n] != NULL; n++)
+    {
+      GFile *file;
+      GError *error;
+      GFileMonitor *monitor;
+
+      file = g_file_new_for_path (authority->priv->rules_dirs[n]);
+      error = NULL;
+      monitor = g_file_monitor_directory (file,
+                                          G_FILE_MONITOR_NONE,
+                                          NULL,
+                                          &error);
+      g_object_unref (file);
+      if (monitor == NULL)
+        {
+          g_warning ("Error monitoring directory %s: %s",
+                     authority->priv->rules_dirs[n],
+                     error->message);
+          g_clear_error (&error);
+        }
+      else
+        {
+          g_signal_connect (monitor,
+                            "changed",
+                            G_CALLBACK (on_dir_monitor_changed),
+                            authority);
+          g_ptr_array_add (p, monitor);
+        }
+    }
+  g_ptr_array_add (p, NULL);
+  authority->priv->dir_monitors = (GFileMonitor**) g_ptr_array_free (p, FALSE);
+}
+
+static void
+polkit_backend_js_authority_constructed (GObject *object)
+{
+  PolkitBackendJsAuthority *authority = POLKIT_BACKEND_JS_AUTHORITY (object);
+  duk_context *cx;
+
+  cx = duk_create_heap (NULL, NULL, NULL, authority, NULL);
+  if (cx == NULL)
+    goto fail;
+
+  authority->priv->cx = cx;
+
+  duk_push_global_object (cx);
+  duk_push_object (cx);
+  duk_put_function_list (cx, -1, js_polkit_functions);
+  duk_put_prop_string (cx, -2, "polkit");
+
+  duk_eval_string (cx, init_js);
+
+  if (authority->priv->rules_dirs == NULL)
+    {
+      authority->priv->rules_dirs = g_new0 (gchar *, 3);
+      authority->priv->rules_dirs[0] = g_strdup (PACKAGE_SYSCONF_DIR "/polkit-1/rules.d");
+      authority->priv->rules_dirs[1] = g_strdup (PACKAGE_DATA_DIR "/polkit-1/rules.d");
+    }
+
+  setup_file_monitors (authority);
+  load_scripts (authority);
+
+  G_OBJECT_CLASS (polkit_backend_js_authority_parent_class)->constructed (object);
+  return;
+
+ fail:
+  g_critical ("Error initializing JavaScript environment");
+  g_assert_not_reached ();
+}
+
+static void
+polkit_backend_js_authority_finalize (GObject *object)
+{
+  PolkitBackendJsAuthority *authority = POLKIT_BACKEND_JS_AUTHORITY (object);
+  guint n;
+
+  for (n = 0; authority->priv->dir_monitors != NULL && authority->priv->dir_monitors[n] != NULL; n++)
+    {
+      GFileMonitor *monitor = authority->priv->dir_monitors[n];
+      g_signal_handlers_disconnect_by_func (monitor,
+                                            G_CALLBACK (on_dir_monitor_changed),
+                                            authority);
+      g_object_unref (monitor);
+    }
+  g_free (authority->priv->dir_monitors);
+  g_strfreev (authority->priv->rules_dirs);
+
+  duk_destroy_heap (authority->priv->cx);
+
+  G_OBJECT_CLASS (polkit_backend_js_authority_parent_class)->finalize (object);
+}
+
+static void
+polkit_backend_js_authority_set_property (GObject      *object,
+                                          guint         property_id,
+                                          const GValue *value,
+                                          GParamSpec   *pspec)
+{
+  PolkitBackendJsAuthority *authority = POLKIT_BACKEND_JS_AUTHORITY (object);
+
+  switch (property_id)
+    {
+      case PROP_RULES_DIRS:
+        g_assert (authority->priv->rules_dirs == NULL);
+        authority->priv->rules_dirs = (gchar **) g_value_dup_boxed (value);
+        break;
+
+      default:
+        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+        break;
+    }
+}
+
+static const gchar *
+polkit_backend_js_authority_get_name (PolkitBackendAuthority *authority)
+{
+  return "js";
+}
+
+static const gchar *
+polkit_backend_js_authority_get_version (PolkitBackendAuthority *authority)
+{
+  return PACKAGE_VERSION;
+}
+
+static PolkitAuthorityFeatures
+polkit_backend_js_authority_get_features (PolkitBackendAuthority *authority)
+{
+  return POLKIT_AUTHORITY_FEATURES_TEMPORARY_AUTHORIZATION;
+}
+
+static void
+polkit_backend_js_authority_class_init (PolkitBackendJsAuthorityClass *klass)
+{
+  GObjectClass *gobject_class;
+  PolkitBackendAuthorityClass *authority_class;
+  PolkitBackendInteractiveAuthorityClass *interactive_authority_class;
+
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize                               = polkit_backend_js_authority_finalize;
+  gobject_class->set_property                           = polkit_backend_js_authority_set_property;
+  gobject_class->constructed                            = polkit_backend_js_authority_constructed;
+
+  authority_class = POLKIT_BACKEND_AUTHORITY_CLASS (klass);
+  authority_class->get_name                             = polkit_backend_js_authority_get_name;
+  authority_class->get_version                          = polkit_backend_js_authority_get_version;
+  authority_class->get_features                         = polkit_backend_js_authority_get_features;
+
+  interactive_authority_class = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_CLASS (klass);
+  interactive_authority_class->get_admin_identities     = polkit_backend_js_authority_get_admin_auth_identities;
+  interactive_authority_class->check_authorization_sync = polkit_backend_js_authority_check_authorization_sync;
+
+  g_object_class_install_property (gobject_class,
+                                   PROP_RULES_DIRS,
+                                   g_param_spec_boxed ("rules-dirs",
+                                                       NULL,
+                                                       NULL,
+                                                       G_TYPE_STRV,
+                                                       G_PARAM_CONSTRUCT_ONLY | G_PARAM_WRITABLE));
+
+
+  g_type_class_add_private (klass, sizeof (PolkitBackendJsAuthorityPrivate));
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static void
+set_property_str (duk_context *cx,
+                  const gchar *name,
+                  const gchar *value)
+{
+  duk_push_string (cx, value);
+  duk_put_prop_string (cx, -2, name);
+}
+
+static void
+set_property_strv (duk_context *cx,
+                   const gchar *name,
+                   GPtrArray   *value)
+{
+  guint n;
+  duk_push_array (cx);
+  for (n = 0; n < value->len; n++)
+    {
+      duk_push_string (cx, g_ptr_array_index (value, n));
+      duk_put_prop_index (cx, -2, n);
+    }
+  duk_put_prop_string (cx, -2, name);
+}
+
+static void
+set_property_int32 (duk_context *cx,
+                    const gchar *name,
+                    gint32       value)
+{
+  duk_push_int (cx, value);
+  duk_put_prop_string (cx, -2, name);
+}
+
+static void
+set_property_bool (duk_context *cx,
+                   const char  *name,
+                   gboolean     value)
+{
+  duk_push_boolean (cx, value);
+  duk_put_prop_string (cx, -2, name);
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static gboolean
+push_subject (duk_context               *cx,
+              PolkitSubject             *subject,
+              PolkitIdentity            *user_for_subject,
+              gboolean                   subject_is_local,
+              gboolean                   subject_is_active,
+              GError                   **error)
+{
+  gboolean ret = FALSE;
+  pid_t pid;
+  uid_t uid;
+  gchar *user_name = NULL;
+  GPtrArray *groups = NULL;
+  struct passwd *passwd;
+  char *seat_str = NULL;
+  char *session_str = NULL;
+
+  if (!duk_get_global_string (cx, "Subject")) {
+    return FALSE;
+  }
+
+  duk_new (cx, 0);
+
+  if (POLKIT_IS_UNIX_PROCESS (subject))
+    {
+      pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (subject));
+    }
+  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))
+    {
+      PolkitSubject *process;
+      process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);
+      if (process == NULL)
+        goto out;
+      pid = polkit_unix_process_get_pid (POLKIT_UNIX_PROCESS (process));
+      g_object_unref (process);
+    }
+  else
+    {
+      g_assert_not_reached ();
+    }
+
+#ifdef HAVE_LIBSYSTEMD
+  if (sd_pid_get_session (pid, &session_str) == 0)
+    {
+      if (sd_session_get_seat (session_str, &seat_str) == 0)
+        {
+          /* do nothing */
+        }
+    }
+#endif /* HAVE_LIBSYSTEMD */
+
+  g_assert (POLKIT_IS_UNIX_USER (user_for_subject));
+  uid = polkit_unix_user_get_uid (POLKIT_UNIX_USER (user_for_subject));
+
+  groups = g_ptr_array_new_with_free_func (g_free);
+
+  passwd = getpwuid (uid);
+  if (passwd == NULL)
+    {
+      user_name = g_strdup_printf ("%d", (gint) uid);
+      g_warning ("Error looking up info for uid %d: %m", (gint) uid);
+    }
+  else
+    {
+      gid_t gids[512];
+      int num_gids = 512;
+
+      user_name = g_strdup (passwd->pw_name);
+
+      if (getgrouplist (passwd->pw_name,
+                        passwd->pw_gid,
+                        gids,
+                        &num_gids) < 0)
+        {
+          g_warning ("Error looking up groups for uid %d: %m", (gint) uid);
+        }
+      else
+        {
+          gint n;
+          for (n = 0; n < num_gids; n++)
+            {
+              struct group *group;
+              group = getgrgid (gids[n]);
+              if (group == NULL)
+                {
+                  g_ptr_array_add (groups, g_strdup_printf ("%d", (gint) gids[n]));
+                }
+              else
+                {
+                  g_ptr_array_add (groups, g_strdup (group->gr_name));
+                }
+            }
+        }
+    }
+
+  set_property_int32 (cx, "pid", pid);
+  set_property_str (cx, "user", user_name);
+  set_property_strv (cx, "groups", groups);
+  set_property_str (cx, "seat", seat_str);
+  set_property_str (cx, "session", session_str);
+  set_property_bool (cx, "local", subject_is_local);
+  set_property_bool (cx, "active", subject_is_active);
+
+  ret = TRUE;
+
+ out:
+  free (session_str);
+  free (seat_str);
+  g_free (user_name);
+  if (groups != NULL)
+    g_ptr_array_unref (groups);
+
+  return ret;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static gboolean
+push_action_and_details (duk_context               *cx,
+                         const gchar               *action_id,
+                         PolkitDetails             *details,
+                         GError                   **error)
+{
+  gchar **keys;
+  guint n;
+
+  if (!duk_get_global_string (cx, "Action")) {
+    return FALSE;
+  }
+
+  duk_new (cx, 0);
+
+  set_property_str (cx, "id", action_id);
+
+  keys = polkit_details_get_keys (details);
+  for (n = 0; keys != NULL && keys[n] != NULL; n++)
+    {
+      gchar *key;
+      const gchar *value;
+      key = g_strdup_printf ("_detail_%s", keys[n]);
+      value = polkit_details_lookup (details, keys[n]);
+      set_property_str (cx, key, value);
+      g_free (key);
+    }
+  g_strfreev (keys);
+
+  return TRUE;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static GList *
+polkit_backend_js_authority_get_admin_auth_identities (PolkitBackendInteractiveAuthority *_authority,
+                                                       PolkitSubject                     *caller,
+                                                       PolkitSubject                     *subject,
+                                                       PolkitIdentity                    *user_for_subject,
+                                                       gboolean                           subject_is_local,
+                                                       gboolean                           subject_is_active,
+                                                       const gchar                       *action_id,
+                                                       PolkitDetails                     *details)
+{
+  PolkitBackendJsAuthority *authority = POLKIT_BACKEND_JS_AUTHORITY (_authority);
+  GList *ret = NULL;
+  guint n;
+  GError *error = NULL;
+  const char *ret_str = NULL;
+  gchar **ret_strs = NULL;
+  duk_context *cx = authority->priv->cx;
+
+  duk_set_top (cx, 0);
+  if (!duk_get_global_string (cx, "polkit")) {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error deleting old rules, not loading new ones");
+      goto out;
+  }
+
+  duk_push_string (cx, "_runAdminRules");
+
+  if (!push_action_and_details (cx, action_id, details, &error))
+    {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error converting action and details to JS object: %s",
+                                    error->message);
+      g_clear_error (&error);
+      goto out;
+    }
+
+  if (!push_subject (cx, subject, user_for_subject, subject_is_local, subject_is_active, &error))
+    {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error converting subject to JS object: %s",
+                                    error->message);
+      g_clear_error (&error);
+      goto out;
+    }
+
+  if (duk_pcall_prop (cx, 0, 2) != DUK_ERR_NONE)
+    {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error evaluating admin rules: ",
+                                    duk_safe_to_string (cx, -1));
+      goto out;
+    }
+
+  ret_str = duk_require_string (cx, -1);
+
+  ret_strs = g_strsplit (ret_str, ",", -1);
+  for (n = 0; ret_strs != NULL && ret_strs[n] != NULL; n++)
+    {
+      const gchar *identity_str = ret_strs[n];
+      PolkitIdentity *identity;
+
+      error = NULL;
+      identity = polkit_identity_from_string (identity_str, &error);
+      if (identity == NULL)
+        {
+          polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                        "Identity `%s' is not valid, ignoring: %s",
+                                        identity_str, error->message);
+          g_clear_error (&error);
+        }
+      else
+        {
+          ret = g_list_prepend (ret, identity);
+        }
+    }
+  ret = g_list_reverse (ret);
+
+ out:
+  g_strfreev (ret_strs);
+  /* fallback to root password auth */
+  if (ret == NULL)
+    ret = g_list_prepend (ret, polkit_unix_user_new (0));
+
+  return ret;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static PolkitImplicitAuthorization
+polkit_backend_js_authority_check_authorization_sync (PolkitBackendInteractiveAuthority *_authority,
+                                                      PolkitSubject                     *caller,
+                                                      PolkitSubject                     *subject,
+                                                      PolkitIdentity                    *user_for_subject,
+                                                      gboolean                           subject_is_local,
+                                                      gboolean                           subject_is_active,
+                                                      const gchar                       *action_id,
+                                                      PolkitDetails                     *details,
+                                                      PolkitImplicitAuthorization        implicit)
+{
+  PolkitBackendJsAuthority *authority = POLKIT_BACKEND_JS_AUTHORITY (_authority);
+  PolkitImplicitAuthorization ret = implicit;
+  GError *error = NULL;
+  gchar *ret_str = NULL;
+  gboolean good = FALSE;
+  duk_context *cx = authority->priv->cx;
+
+  duk_set_top (cx, 0);
+  if (!duk_get_global_string (cx, "polkit")) {
+      goto out;
+  }
+
+  duk_push_string (cx, "_runRules");
+
+  if (!push_action_and_details (cx, action_id, details, &error))
+    {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error converting action and details to JS object: %s",
+                                    error->message);
+      g_clear_error (&error);
+      goto out;
+    }
+
+  if (!push_subject (cx, subject, user_for_subject, subject_is_local, subject_is_active, &error))
+    {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error converting subject to JS object: %s",
+                                    error->message);
+      g_clear_error (&error);
+      goto out;
+    }
+
+  if (duk_pcall_prop (cx, 0, 2) != DUK_ERR_NONE)
+  {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Error evaluating authorization rules: ",
+                                    duk_safe_to_string (cx, -1));
+      goto out;
+  }
+
+  if (duk_is_null(cx, -1)) {
+    good = TRUE;
+    goto out;
+  }
+  ret_str = g_strdup (duk_require_string (cx, -1));
+  if (!polkit_implicit_authorization_from_string (ret_str, &ret))
+    {
+      polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),
+                                    "Returned result `%s' is not valid",
+                                    ret_str);
+      goto out;
+    }
+
+  good = TRUE;
+
+ out:
+  if (!good)
+    ret = POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED;
+  if (ret_str != NULL)
+      g_free (ret_str);
+
+  return ret;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static duk_ret_t
+js_polkit_log (duk_context *cx)
+{
+  const char *str = duk_require_string (cx, 0);
+  fprintf (stderr, "%s\n", str);
+  return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+static const gchar *
+get_signal_name (gint signal_number)
+{
+  switch (signal_number)
+    {
+#define _HANDLE_SIG(sig) case sig: return #sig;
+    _HANDLE_SIG (SIGHUP);
+    _HANDLE_SIG (SIGINT);
+    _HANDLE_SIG (SIGQUIT);
+    _HANDLE_SIG (SIGILL);
+    _HANDLE_SIG (SIGABRT);
+    _HANDLE_SIG (SIGFPE);
+    _HANDLE_SIG (SIGKILL);
+    _HANDLE_SIG (SIGSEGV);
+    _HANDLE_SIG (SIGPIPE);
+    _HANDLE_SIG (SIGALRM);
+    _HANDLE_SIG (SIGTERM);
+    _HANDLE_SIG (SIGUSR1);
+    _HANDLE_SIG (SIGUSR2);
+    _HANDLE_SIG (SIGCHLD);
+    _HANDLE_SIG (SIGCONT);
+    _HANDLE_SIG (SIGSTOP);
+    _HANDLE_SIG (SIGTSTP);
+    _HANDLE_SIG (SIGTTIN);
+    _HANDLE_SIG (SIGTTOU);
+    _HANDLE_SIG (SIGBUS);
+#ifdef SIGPOLL
+    _HANDLE_SIG (SIGPOLL);
+#endif
+    _HANDLE_SIG (SIGPROF);
+    _HANDLE_SIG (SIGSYS);
+    _HANDLE_SIG (SIGTRAP);
+    _HANDLE_SIG (SIGURG);
+    _HANDLE_SIG (SIGVTALRM);
+    _HANDLE_SIG (SIGXCPU);
+    _HANDLE_SIG (SIGXFSZ);
+#undef _HANDLE_SIG
+    default:
+      break;
+    }
+  return "UNKNOWN_SIGNAL";
+}
+
+typedef struct
+{
+  GMainLoop *loop;
+  GAsyncResult *res;
+} SpawnData;
+
+static void
+spawn_cb (GObject       *source_object,
+          GAsyncResult  *res,
+          gpointer       user_data)
+{
+  SpawnData *data = (SpawnData *)user_data;
+  data->res = (GAsyncResult*)g_object_ref (res);
+  g_main_loop_quit (data->loop);
+}
+
+static duk_ret_t
+js_polkit_spawn (duk_context *cx)
+{
+#if (DUK_VERSION >= 20000)
+  duk_ret_t ret = DUK_RET_ERROR;
+#else
+  duk_ret_t ret = DUK_RET_INTERNAL_ERROR;
+#endif
+  gchar *standard_output = NULL;
+  gchar *standard_error = NULL;
+  gint exit_status;
+  GError *error = NULL;
+  guint32 array_len;
+  gchar **argv = NULL;
+  GMainContext *context = NULL;
+  GMainLoop *loop = NULL;
+  SpawnData data = {0};
+  char *err_str = NULL;
+  guint n;
+
+  if (!duk_is_array (cx, 0))
+    goto out;
+
+  array_len = duk_get_length (cx, 0);
+
+  argv = g_new0 (gchar*, array_len + 1);
+  for (n = 0; n < array_len; n++)
+    {
+      duk_get_prop_index (cx, 0, n);
+      argv[n] = g_strdup (duk_to_string (cx, -1));
+      duk_pop (cx);
+    }
+
+  context = g_main_context_new ();
+  loop = g_main_loop_new (context, FALSE);
+
+  g_main_context_push_thread_default (context);
+
+  data.loop = loop;
+  utils_spawn ((const gchar *const *) argv,
+               10, /* timeout_seconds */
+               NULL, /* cancellable */
+               spawn_cb,
+               &data);
+
+  g_main_loop_run (loop);
+
+  g_main_context_pop_thread_default (context);
+
+  if (!utils_spawn_finish (data.res,
+                           &exit_status,
+                           &standard_output,
+                           &standard_error,
+                           &error))
+    {
+      err_str = g_strdup_printf ("Error spawning helper: %s (%s, %d)",
+                                 error->message, g_quark_to_string (error->domain), error->code);
+      g_clear_error (&error);
+      goto out;
+    }
+
+  if (!(WIFEXITED (exit_status) && WEXITSTATUS (exit_status) == 0))
+    {
+      GString *gstr;
+      gstr = g_string_new (NULL);
+      if (WIFEXITED (exit_status))
+        {
+          g_string_append_printf (gstr,
+                                  "Helper exited with non-zero exit status %d",
+                                  WEXITSTATUS (exit_status));
+        }
+      else if (WIFSIGNALED (exit_status))
+        {
+          g_string_append_printf (gstr,
+                                  "Helper was signaled with signal %s (%d)",
+                                  get_signal_name (WTERMSIG (exit_status)),
+                                  WTERMSIG (exit_status));
+        }
+      g_string_append_printf (gstr, ", stdout=`%s', stderr=`%s'",
+                              standard_output, standard_error);
+      err_str = g_string_free (gstr, FALSE);
+      goto out;
+    }
+
+  duk_push_string (cx, standard_output);
+  ret = 1;
+
+ out:
+  g_strfreev (argv);
+  g_free (standard_output);
+  g_free (standard_error);
+  g_clear_object (&data.res);
+  if (loop != NULL)
+    g_main_loop_unref (loop);
+  if (context != NULL)
+    g_main_context_unref (context);
+
+  if (err_str)
+    duk_error (cx, DUK_ERR_ERROR, err_str);
+
+  return ret;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+
+static duk_ret_t
+js_polkit_user_is_in_netgroup (duk_context *cx)
+{
+  const char *user;
+  const char *netgroup;
+  gboolean is_in_netgroup = FALSE;
+
+  user = duk_require_string (cx, 0);
+  netgroup = duk_require_string (cx, 1);
+
+  if (innetgr (netgroup,
+               NULL,  /* host */
+               user,
+               NULL)) /* domain */
+    {
+      is_in_netgroup = TRUE;
+    }
+
+  duk_push_boolean (cx, is_in_netgroup);
+  return 1;
+}
+
+/* ---------------------------------------------------------------------------------------------------- */
+
+typedef struct
+{
+  GSimpleAsyncResult *simple; /* borrowed reference */
+  GMainContext *main_context; /* may be NULL */
+
+  GCancellable *cancellable;  /* may be NULL */
+  gulong cancellable_handler_id;
+
+  GPid child_pid;
+  gint child_stdout_fd;
+  gint child_stderr_fd;
+
+  GIOChannel *child_stdout_channel;
+  GIOChannel *child_stderr_channel;
+
+  GSource *child_watch_source;
+  GSource *child_stdout_source;
+  GSource *child_stderr_source;
+
+  guint timeout_seconds;
+  gboolean timed_out;
+  GSource *timeout_source;
+
+  GString *child_stdout;
+  GString *child_stderr;
+
+  gint exit_status;
+} UtilsSpawnData;
+
+static void
+utils_child_watch_from_release_cb (GPid     pid,
+                                   gint     status,
+                                   gpointer user_data)
+{
+}
+
+static void
+utils_spawn_data_free (UtilsSpawnData *data)
+{
+  if (data->timeout_source != NULL)
+    {
+      g_source_destroy (data->timeout_source);
+      data->timeout_source = NULL;
+    }
+
+  /* Nuke the child, if necessary */
+  if (data->child_watch_source != NULL)
+    {
+      g_source_destroy (data->child_watch_source);
+      data->child_watch_source = NULL;
+    }
+
+  if (data->child_pid != 0)
+    {
+      GSource *source;
+      kill (data->child_pid, SIGTERM);
+      /* OK, we need to reap for the child ourselves - we don't want
+       * to use waitpid() because that might block the calling
+       * thread (the child might handle SIGTERM and use several
+       * seconds for cleanup/rollback).
+       *
+       * So we use GChildWatch instead.
+       *
+       * Avoid taking a references to ourselves. but note that we need
+       * to pass the GSource so we can nuke it once handled.
+       */
+      source = g_child_watch_source_new (data->child_pid);
+      g_source_set_callback (source,
+                             (GSourceFunc) utils_child_watch_from_release_cb,
+                             source,
+                             (GDestroyNotify) g_source_destroy);
+      g_source_attach (source, data->main_context);
+      g_source_unref (source);
+      data->child_pid = 0;
+    }
+
+  if (data->child_stdout != NULL)
+    {
+      g_string_free (data->child_stdout, TRUE);
+      data->child_stdout = NULL;
+    }
+
+  if (data->child_stderr != NULL)
+    {
+      g_string_free (data->child_stderr, TRUE);
+      data->child_stderr = NULL;
+    }
+
+  if (data->child_stdout_channel != NULL)
+    {
+      g_io_channel_unref (data->child_stdout_channel);
+      data->child_stdout_channel = NULL;
+    }
+  if (data->child_stderr_channel != NULL)
+    {
+      g_io_channel_unref (data->child_stderr_channel);
+      data->child_stderr_channel = NULL;
+    }
+
+  if (data->child_stdout_source != NULL)
+    {
+      g_source_destroy (data->child_stdout_source);
+      data->child_stdout_source = NULL;
+    }
+  if (data->child_stderr_source != NULL)
+    {
+      g_source_destroy (data->child_stderr_source);
+      data->child_stderr_source = NULL;
+    }
+
+  if (data->child_stdout_fd != -1)
+    {
+      g_warn_if_fail (close (data->child_stdout_fd) == 0);
+      data->child_stdout_fd = -1;
+    }
+  if (data->child_stderr_fd != -1)
+    {
+      g_warn_if_fail (close (data->child_stderr_fd) == 0);
+      data->child_stderr_fd = -1;
+    }
+
+  if (data->cancellable_handler_id > 0)
+    {
+      g_cancellable_disconnect (data->cancellable, data->cancellable_handler_id);
+      data->cancellable_handler_id = 0;
+    }
+
+  if (data->main_context != NULL)
+    g_main_context_unref (data->main_context);
+
+  if (data->cancellable != NULL)
+    g_object_unref (data->cancellable);
+
+  g_slice_free (UtilsSpawnData, data);
+}
+
+/* called in the thread where @cancellable was cancelled */
+static void
+utils_on_cancelled (GCancellable *cancellable,
+                    gpointer      user_data)
+{
+  UtilsSpawnData *data = (UtilsSpawnData *)user_data;
+  GError *error;
+
+  error = NULL;
+  g_warn_if_fail (g_cancellable_set_error_if_cancelled (cancellable, &error));
+  g_simple_async_result_take_error (data->simple, error);
+  g_simple_async_result_complete_in_idle (data->simple);
+  g_object_unref (data->simple);
+}
+
+static gboolean
+utils_read_child_stderr (GIOChannel *channel,
+                         GIOCondition condition,
+                         gpointer user_data)
+{
+  UtilsSpawnData *data = (UtilsSpawnData *)user_data;
+  gchar buf[1024];
+  gsize bytes_read;
+
+  g_io_channel_read_chars (channel, buf, sizeof buf, &bytes_read, NULL);
+  g_string_append_len (data->child_stderr, buf, bytes_read);
+  return TRUE;
+}
+
+static gboolean
+utils_read_child_stdout (GIOChannel *channel,
+                         GIOCondition condition,
+                         gpointer user_data)
+{
+  UtilsSpawnData *data = (UtilsSpawnData *)user_data;
+  gchar buf[1024];
+  gsize bytes_read;
+
+  g_io_channel_read_chars (channel, buf, sizeof buf, &bytes_read, NULL);
+  g_string_append_len (data->child_stdout, buf, bytes_read);
+  return TRUE;
+}
+
+static void
+utils_child_watch_cb (GPid     pid,
+                      gint     status,
+                      gpointer user_data)
+{
+  UtilsSpawnData *data = (UtilsSpawnData *)user_data;
+  gchar *buf;
+  gsize buf_size;
+
+  if (g_io_channel_read_to_end (data->child_stdout_channel, &buf, &buf_size, NULL) == G_IO_STATUS_NORMAL)
+    {
+      g_string_append_len (data->child_stdout, buf, buf_size);
+      g_free (buf);
+    }
+  if (g_io_channel_read_to_end (data->child_stderr_channel, &buf, &buf_size, NULL) == G_IO_STATUS_NORMAL)
+    {
+      g_string_append_len (data->child_stderr, buf, buf_size);
+      g_free (buf);
+    }
+
+  data->exit_status = status;
+
+  /* ok, child watch is history, make sure we don't free it in spawn_data_free() */
+  data->child_pid = 0;
+  data->child_watch_source = NULL;
+
+  /* we're done */
+  g_simple_async_result_complete_in_idle (data->simple);
+  g_object_unref (data->simple);
+}
+
+static gboolean
+utils_timeout_cb (gpointer user_data)
+{
+  UtilsSpawnData *data = (UtilsSpawnData *)user_data;
+
+  data->timed_out = TRUE;
+
+  /* ok, timeout is history, make sure we don't free it in spawn_data_free() */
+  data->timeout_source = NULL;
+
+  /* we're done */
+  g_simple_async_result_complete_in_idle (data->simple);
+  g_object_unref (data->simple);
+
+  return FALSE; /* remove source */
+}
+
+static void
+utils_spawn (const gchar *const  *argv,
+             guint                timeout_seconds,
+             GCancellable        *cancellable,
+             GAsyncReadyCallback  callback,
+             gpointer             user_data)
+{
+  UtilsSpawnData *data;
+  GError *error;
+
+  data = g_slice_new0 (UtilsSpawnData);
+  data->timeout_seconds = timeout_seconds;
+  data->simple = g_simple_async_result_new (NULL,
+                                            callback,
+                                            user_data,
+                                            (gpointer*)utils_spawn);
+  data->main_context = g_main_context_get_thread_default ();
+  if (data->main_context != NULL)
+    g_main_context_ref (data->main_context);
+
+  data->cancellable = cancellable != NULL ? (GCancellable*)g_object_ref (cancellable) : NULL;
+
+  data->child_stdout = g_string_new (NULL);
+  data->child_stderr = g_string_new (NULL);
+  data->child_stdout_fd = -1;
+  data->child_stderr_fd = -1;
+
+  /* the life-cycle of UtilsSpawnData is tied to its GSimpleAsyncResult */
+  g_simple_async_result_set_op_res_gpointer (data->simple, data, (GDestroyNotify) utils_spawn_data_free);
+
+  error = NULL;
+  if (data->cancellable != NULL)
+    {
+      /* could already be cancelled */
+      error = NULL;
+      if (g_cancellable_set_error_if_cancelled (data->cancellable, &error))
+        {
+          g_simple_async_result_take_error (data->simple, error);
+          g_simple_async_result_complete_in_idle (data->simple);
+          g_object_unref (data->simple);
+          goto out;
+        }
+
+      data->cancellable_handler_id = g_cancellable_connect (data->cancellable,
+                                                            G_CALLBACK (utils_on_cancelled),
+                                                            data,
+                                                            NULL);
+    }
+
+  error = NULL;
+  if (!g_spawn_async_with_pipes (NULL, /* working directory */
+                                 (gchar **) argv,
+                                 NULL, /* envp */
+                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD,
+                                 NULL, /* child_setup */
+                                 NULL, /* child_setup's user_data */
+                                 &(data->child_pid),
+                                 NULL, /* gint *stdin_fd */
+                                 &(data->child_stdout_fd),
+                                 &(data->child_stderr_fd),
+                                 &error))
+    {
+      g_prefix_error (&error, "Error spawning: ");
+      g_simple_async_result_take_error (data->simple, error);
+      g_simple_async_result_complete_in_idle (data->simple);
+      g_object_unref (data->simple);
+      goto out;
+    }
+
+  if (timeout_seconds > 0)
+    {
+      data->timeout_source = g_timeout_source_new_seconds (timeout_seconds);
+      g_source_set_priority (data->timeout_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (data->timeout_source, utils_timeout_cb, data, NULL);
+      g_source_attach (data->timeout_source, data->main_context);
+      g_source_unref (data->timeout_source);
+    }
+
+  data->child_watch_source = g_child_watch_source_new (data->child_pid);
+  g_source_set_callback (data->child_watch_source, (GSourceFunc) utils_child_watch_cb, data, NULL);
+  g_source_attach (data->child_watch_source, data->main_context);
+  g_source_unref (data->child_watch_source);
+
+  data->child_stdout_channel = g_io_channel_unix_new (data->child_stdout_fd);
+  g_io_channel_set_flags (data->child_stdout_channel, G_IO_FLAG_NONBLOCK, NULL);
+  data->child_stdout_source = g_io_create_watch (data->child_stdout_channel, G_IO_IN);
+  g_source_set_callback (data->child_stdout_source, (GSourceFunc) utils_read_child_stdout, data, NULL);
+  g_source_attach (data->child_stdout_source, data->main_context);
+  g_source_unref (data->child_stdout_source);
+
+  data->child_stderr_channel = g_io_channel_unix_new (data->child_stderr_fd);
+  g_io_channel_set_flags (data->child_stderr_channel, G_IO_FLAG_NONBLOCK, NULL);
+  data->child_stderr_source = g_io_create_watch (data->child_stderr_channel, G_IO_IN);
+  g_source_set_callback (data->child_stderr_source, (GSourceFunc) utils_read_child_stderr, data, NULL);
+  g_source_attach (data->child_stderr_source, data->main_context);
+  g_source_unref (data->child_stderr_source);
+
+ out:
+  ;
+}
+
+gboolean
+utils_spawn_finish (GAsyncResult   *res,
+                    gint           *out_exit_status,
+                    gchar         **out_standard_output,
+                    gchar         **out_standard_error,
+                    GError        **error)
+{
+  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (res);
+  UtilsSpawnData *data;
+  gboolean ret = FALSE;
+
+  g_return_val_if_fail (G_IS_ASYNC_RESULT (res), FALSE);
+  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+  g_warn_if_fail (g_simple_async_result_get_source_tag (simple) == utils_spawn);
+
+  if (g_simple_async_result_propagate_error (simple, error))
+    goto out;
+
+  data = (UtilsSpawnData*)g_simple_async_result_get_op_res_gpointer (simple);
+
+  if (data->timed_out)
+    {
+      g_set_error (error,
+                   G_IO_ERROR,
+                   G_IO_ERROR_TIMED_OUT,
+                   "Timed out after %d seconds",
+                   data->timeout_seconds);
+      goto out;
+    }
+
+  if (out_exit_status != NULL)
+    *out_exit_status = data->exit_status;
+
+  if (out_standard_output != NULL)
+    *out_standard_output = g_strdup (data->child_stdout->str);
+
+  if (out_standard_error != NULL)
+    *out_standard_error = g_strdup (data->child_stderr->str);
+
+  ret = TRUE;
+
+ out:
+  return ret;
+}
diff --git a/src/programs/Makefile.am b/src/programs/Makefile.am
index d69853c..f19a7c8 100644
--- a/src/programs/Makefile.am
+++ b/src/programs/Makefile.am
@@ -84,6 +84,8 @@ pkaction_LDADD =  	                      				\
 
 # ----------------------------------------------------------------------------------------------------
 
+EXTRA_DIST = meson.build
+
 clean-local :
 	rm -f *~
 
diff --git a/src/programs/meson.build b/src/programs/meson.build
new file mode 100644
index 0000000..03794be
--- /dev/null
+++ b/src/programs/meson.build
@@ -0,0 +1,16 @@
+programs = [
+  ['pkexec', auth_deps + [libpolkit_agent_dep]],
+  ['pkcheck', [libpolkit_agent_dep]],
+  ['pkaction', [libpolkit_gobject_dep]],
+  ['pkttyagent', [libpolkit_agent_dep]],
+]
+
+foreach program: programs
+  executable(
+    program[0],
+    program[0] + '.c',
+    include_directories: top_inc,
+    dependencies: program[1],
+    install: true,
+  )
+endforeach
diff --git a/src/symbol.map b/src/symbol.map
new file mode 100644
index 0000000..2d38225
--- /dev/null
+++ b/src/symbol.map
@@ -0,0 +1,6 @@
+{
+global:
+  polkit_*;
+local:
+  *;
+};
diff --git a/subprojects/mocklibc.wrap b/subprojects/mocklibc.wrap
new file mode 100644
index 0000000..af82298
--- /dev/null
+++ b/subprojects/mocklibc.wrap
@@ -0,0 +1,10 @@
+[wrap-file]
+directory = mocklibc-1.0
+
+source_url = https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/mocklibc/mocklibc-1.0.tar.gz
+source_filename = mocklibc-1.0.tar.gz
+source_hash = b2236a6af1028414783e9734a46ea051916ec226479d6a55a3bb823bff68f120
+
+patch_url = https://wrapdb.mesonbuild.com/v1/projects/mocklibc/1.0/2/get_zip
+patch_filename = mocklibc-1.0-2-wrap.zip
+patch_hash = 0280f96a2eeb3c023e5acf4e00cef03d362868218d4a85347ea45137c0ef6c56
diff --git a/subprojects/packagecache/mocklibc-1.0-2-wrap.zip b/subprojects/packagecache/mocklibc-1.0-2-wrap.zip
new file mode 100644
index 0000000..656ebaf
Binary files /dev/null and b/subprojects/packagecache/mocklibc-1.0-2-wrap.zip differ
diff --git a/subprojects/packagecache/mocklibc-1.0.tar.gz b/subprojects/packagecache/mocklibc-1.0.tar.gz
new file mode 100644
index 0000000..568a053
Binary files /dev/null and b/subprojects/packagecache/mocklibc-1.0.tar.gz differ
diff --git a/test/Makefile.am b/test/Makefile.am
index 59d0680..aacc892 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -6,7 +6,10 @@ noinst_LTLIBRARIES = libpolkit-test-helper.la
 libpolkit_test_helper_la_SOURCES = polkittesthelper.c polkittesthelper.h
 libpolkit_test_helper_la_LIBADD = $(GLIB_LIBS)
 
-EXTRA_DIST = data
+EXTRA_DIST =		\
+	data		\
+	meson.build	\
+	$(NULL)
 
 # Use mocklibc to override NSS services for tests
 export MOCK_PASSWD   := $(abs_top_srcdir)/test/data/etc/passwd
diff --git a/test/meson.build b/test/meson.build
new file mode 100644
index 0000000..3f02d35
--- /dev/null
+++ b/test/meson.build
@@ -0,0 +1,26 @@
+libpolkit_test_helper = static_library(
+  'polkit-test-helper',
+  sources: 'polkittesthelper.c',
+  dependencies: glib_dep,
+)
+
+libpolkit_test_helper_dep = declare_dependency(
+  include_directories: '.',
+  dependencies: glib_dep,
+  link_with: libpolkit_test_helper,
+)
+
+libmocklibc = subproject('mocklibc').get_variable('libmocklibc')
+
+test_data_dir = meson.current_source_dir() / 'data'
+test_etc_dir = test_data_dir / 'etc'
+
+test_env = environment()
+test_env.set('LD_PRELOAD', libmocklibc.full_path())
+test_env.set('MOCK_PASSWD', test_etc_dir / 'passwd')
+test_env.set('MOCK_GROUP', test_etc_dir / 'group')
+test_env.set('MOCK_NETGROUP', test_etc_dir / 'netgroup')
+test_env.set('POLKIT_TEST_DATA', test_data_dir)
+
+subdir('polkit')
+subdir('polkitbackend')
diff --git a/test/polkit/Makefile.am b/test/polkit/Makefile.am
index 1e0a23f..261d1d5 100644
--- a/test/polkit/Makefile.am
+++ b/test/polkit/Makefile.am
@@ -48,6 +48,8 @@ polkitidentitytest_SOURCES = polkitidentitytest.c
 check_PROGRAMS = $(TEST_PROGS)
 TESTS = $(TEST_PROGS)
 
+EXTRA_DIST = meson.build
+
 clean-local :
 	rm -f *~
 
diff --git a/test/polkit/meson.build b/test/polkit/meson.build
new file mode 100644
index 0000000..9c5254f
--- /dev/null
+++ b/test/polkit/meson.build
@@ -0,0 +1,27 @@
+test_units = [
+  'polkitunixusertest',
+  'polkitunixgrouptest',
+  'polkitunixnetgrouptest',
+  'polkitidentitytest',
+]
+
+c_flags = [
+  '-D_POLKIT_COMPILATION',
+  '-D_POLKIT_BACKEND_COMPILATION',
+]
+
+foreach test_unit: test_units
+  exe = executable(
+    test_unit,
+    test_unit + '.c',
+    dependencies: libpolkit_gobject_dep,
+    c_args: c_flags,
+  )
+
+  test(
+    test_unit,
+    exe,
+    env: test_env,
+    is_parallel: false,
+  )
+endforeach
diff --git a/test/polkitbackend/Makefile.am b/test/polkitbackend/Makefile.am
index b714c60..267a2d2 100644
--- a/test/polkitbackend/Makefile.am
+++ b/test/polkitbackend/Makefile.am
@@ -48,6 +48,8 @@ TEST_PROGS += polkitbackendjsauthoritytest-wrapper.py
 noinst_PROGRAMS = polkitbackendjsauthoritytest
 TESTS = $(TEST_PROGS)
 
+EXTRA_DIST = meson.build
+
 clean-local :
 	rm -f *~
 
diff --git a/test/polkitbackend/meson.build b/test/polkitbackend/meson.build
new file mode 100644
index 0000000..98ba120
--- /dev/null
+++ b/test/polkitbackend/meson.build
@@ -0,0 +1,32 @@
+test_unit = 'test-polkitbackendjsauthority'
+
+deps = [
+  libpolkit_gobject_dep,
+  libpolkit_test_helper_dep,
+]
+
+c_flags = [
+  '-D_POLKIT_COMPILATION',
+  '-D_POLKIT_BACKEND_COMPILATION',
+]
+
+test_env.set('TOP_BUILD_DIR', build_root)
+test_env.set('TOP_SRC_DIR', source_root)
+
+exe = executable(
+  test_unit,
+  test_unit + '.c',
+  include_directories: top_inc,
+  dependencies: deps,
+  c_args: c_flags,
+  link_with: libpolkit_backend,
+)
+
+prog = find_program('polkitbackendjsauthoritytest-wrapper.py')
+
+test(
+  test_unit,
+  prog,
+  env: test_env,
+  is_parallel: false,
+)
diff --git a/test/polkitbackend/polkitbackendjsauthoritytest-wrapper.py b/test/polkitbackend/polkitbackendjsauthoritytest-wrapper.py
index 2a4e160..8e067eb 100755
--- a/test/polkitbackend/polkitbackendjsauthoritytest-wrapper.py
+++ b/test/polkitbackend/polkitbackendjsauthoritytest-wrapper.py
@@ -28,13 +28,22 @@ class TestPolkitBackendJsAuthority(dbusmock.DBusTestCase):
     @classmethod
     def setUpClass(klass):
         klass.start_system_bus()
+        klass.mocklibc_path = None
 
-        klass.top_build_dir = '../../'
         if 'TOP_BUILD_DIR' in os.environ:
             klass.top_build_dir = os.environ['TOP_BUILD_DIR']
-        klass.mocklibc_path = klass.top_build_dir + '/test/mocklibc/bin/mocklibc'
-        assert(os.path.exists(klass.mocklibc_path))
+            klass.mocklibc_path = klass.top_build_dir  + '/subprojects/mocklibc-1.0/bin/mocklibc'
+
+        # suppose autotools over meson
+        if not os.path.exists(klass.mocklibc_path):
+            klass.top_build_dir = '../../'
+            klass.mocklibc_path = klass.top_build_dir + '/test/mocklibc/bin/mocklibc'
         print ('Top build dir: %s' % klass.top_build_dir)
+        print ('mocklibc path: %s' % klass.mocklibc_path)
+        assert(os.path.exists(klass.mocklibc_path))
+
+        # WORKAROUND - unzipped mocklibc does not preserve file permissions
+        os.chmod(klass.mocklibc_path, 0o755)
 
         klass.top_src_dir = os.path.dirname(os.path.realpath(__file__)) + '/../../'
         if 'TOP_SRC_DIR' in os.environ:
@@ -54,7 +63,13 @@ class TestPolkitBackendJsAuthority(dbusmock.DBusTestCase):
     def test_polkitbackendjsauthoritytest(self):
         # Add '; exit 0' at the end of the cmd line if launching fails and you
         # want to capture the error output
-        out = subprocess.check_output(self.mocklibc_path + ' ' + self.top_build_dir + '/test/polkitbackend/polkitbackendjsauthoritytest',
+        test_path = self.top_build_dir + '/test/polkitbackend/test-polkitbackendjsauthority'
+
+        if not os.path.exists(test_path):
+            print('\n %s... not found' % test_path)
+            test_path = self.top_build_dir + '/test/polkitbackend/polkitbackendjsauthoritytest'
+
+        out = subprocess.check_output(self.mocklibc_path + ' ' + test_path,
                                       stderr=subprocess.STDOUT,
                                       shell=True,
                                       universal_newlines=True)
